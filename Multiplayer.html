<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Blocky Survivor: Legends</title>
    
    <!-- Firebase Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCBNi6qxOjYl5L8sZrH653l_7lbQ0jN8Sk",
            authDomain: "blockylegends-efdad.firebaseapp.com",
            databaseURL: "https://blockylegends-efdad-default-rtdb.firebaseio.com",
            projectId: "blockylegends-efdad",
            storageBucket: "blockylegends-efdad.firebasestorage.app",
            messagingSenderId: "529101552502",
            appId: "1:529101552502:web:89803f86f303b40927d857"
        };
        
        const app = initializeApp(firebaseConfig);
        window.database = getDatabase(app);
        window.dbRef = ref;
        window.dbSet = set;
        window.dbOnValue = onValue;
        window.dbUpdate = update;
        window.dbRemove = remove;
    </script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #111;
            color: #eee;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        
        canvas {
            background: #1a1a1a;
            display: block;
            border-radius: 8px;
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 80vh;
        }
        
        /* General Button Style */
        .game-btn {
            font-family: 'Press Start 2P', cursive;
            background-color: #fff;
            color: #000;
            border: none;
            border-bottom: 4px solid #999;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            position: relative;
        }
        
        .game-btn:hover {
            background-color: #f0f0f0;
            transform: translateY(-2px);
        }
        
        .game-btn:active {
            transform: translateY(2px);
            border-bottom-width: 0;
            margin-top: 4px;
        }

        .game-btn:disabled {
            background-color: #555;
            border-color: #333;
            color: #888;
            cursor: not-allowed;
            transform: none;
            margin-top: 0;
            border-bottom-width: 4px;
        }

        /* Hero Cards */
        .char-select-card {
            border: 4px solid #555;
            border-radius: 8px;
            transition: all 0.2s ease;
            background-color: #2a2a2a;
            width: 160px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        .char-select-card:hover {
            transform: scale(1.05);
            border-color: #f7b42c;
            background-color: #333;
        }
        .char-block {
            width: 60px;
            height: 60px;
            margin-bottom: 1rem;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
        }

        /* Shop Item Card */
        .shop-card {
            background-color: #2a2a2a;
            border: 2px solid #555;
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
        }

        /* XP Bar Styles */
        .xp-container {
            width: 100%;
            height: 24px;
            background-color: #333;
            border: 2px solid #fff;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.2s ease-out;
        }

        /* Wave Text Animation */
        @keyframes wavePulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .wave-anim {
            animation: wavePulse 2s infinite;
        }

        /* Stats Grid */
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 2px solid #333;
        }
        .stat-row:last-child {
            border-bottom: none;
        }

        /* Ability Sidebar */
#abilitySidebar::-webkit-scrollbar {
    width: 4px;
}
#abilitySidebar::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 2px;
}
#abilitySidebar::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.3);
    border-radius: 2px;
}
.ability-card {
    background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(20,20,20,0.95) 100%);
    border: 2px solid #444;
    border-radius: 8px;
    padding: 8px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}
.ability-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: left 0.5s;
}
.ability-card:hover::before {
    left: 100%;
}
.ability-card-offense {
    border-color: #dc2626;
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
}
.ability-card-defense {
    border-color: #2563eb;
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
}
.ability-card-utility {
    border-color: #9333ea;
    box-shadow: 0 4px 12px rgba(147, 51, 234, 0.4);
}
.ability-icon {
    font-size: 24px;
    display: block;
    margin-bottom: 4px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
}
.ability-stack {
    position: absolute;
    top: 2px;
    right: 4px;
    background: rgba(0,0,0,0.8);
    color: #fbbf24;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 10px;
    border: 1px solid #fbbf24;
}
</parameter>
        
    </style>
</head>
<body class="flex flex-col items-center justify-center h-full w-full p-2">

    <div class="w-full max-w-4xl text-center relative">
        
        <!-- Coin Display (Global) - MOVED LOWER & BIGGER -->
<div id="coinDisplayMenu" class="absolute top-24 right-4 text-yellow-400 flex items-center gap-3 bg-gray-900 p-3 rounded-lg border-2 border-yellow-600 z-50 shadow-lg">
    <div class="w-6 h-6 bg-yellow-400 rounded-full border-2 border-white"></div>
    <span id="menuCoins" class="text-xl font-bold">0</span>
</div>
<!-- PAC Rank Display (Top Left) -->
<div id="pacDisplayMenu" class="absolute top-24 left-4 text-purple-400 flex items-center gap-3 bg-gray-900 p-3 rounded-lg border-2 border-purple-600 z-50 shadow-lg cursor-pointer hover:scale-105 transition-transform">
    <div class="w-6 h-6 bg-purple-400 rounded-full border-2 border-white animate-pulse"></div>
    <div>
        <div class="text-[10px] text-gray-400">RANK</div>
        <span id="pacRankText" class="text-lg font-bold uppercase">ROOKIE</span>
    </div>
</div>
        
        <!-- Game Title -->
        <h1 id="gameTitle" class="text-2xl sm:text-5xl font-bold mb-8 text-yellow-400 drop-shadow-[4px_4px_0_rgba(0,0,0,1)] tracking-wider">
            BLOCKY LEGENDS
        </h1>

        <!-- MAIN MENU SCREEN -->
        <div id="mainMenuScreen" class="flex flex-col items-center gap-6">
           <!-- Main Action Buttons -->
<button id="btnPlay" class="game-btn px-8 py-4 text-xl sm:text-2xl w-64 bg-green-500 border-green-700 hover:bg-green-400 text-white">
    PLAY
</button>
<button id="btnShop" class="game-btn px-8 py-4 text-lg sm:text-xl w-64 bg-yellow-500 border-yellow-700 hover:bg-yellow-400 text-white">
    SHOP
</button>
<button id="btnStats" class="game-btn px-8 py-4 text-lg sm:text-xl w-64 bg-gray-200 border-gray-400">
    STATS
</button>

<!-- More Button -->
<div class="flex gap-3 mt-4 justify-center">
    <button id="btnMore" class="game-btn px-8 py-3 text-lg w-48 bg-gray-700 border-gray-900 text-white hover:bg-gray-600">
        üìã MORE
    </button>
</div>
</div>
<!-- Code Redemption Box (Left Side) - NOW INSIDE MAIN MENU -->
            <div id="codeRedemptionBox" class="absolute left-4 bottom-4 w-56 bg-gray-800 p-3 rounded-lg border-2 border-gray-600 z-40">
                <h3 class="text-xs text-yellow-400 mb-2">üéÅ REDEEM CODE</h3>
                <input 
                    type="text" 
                    id="codeInput" 
                    placeholder="Enter code..."
                    class="w-full px-3 py-2 bg-gray-900 text-white text-xs border border-gray-600 rounded mb-2 uppercase"
                    maxlength="20"
                >
                <button id="btnRedeem" class="game-btn px-4 py-2 text-xs w-full bg-green-500 border-green-700 text-white">
                    REDEEM
                </button>
                <div id="codeMessage" class="text-[10px] mt-2 text-center hidden"></div>
            </div>

       </div>
 

<div class="text-[10px] text-gray-500 mt-6">v2.5 - CHRISTMAS</div>

        </div>
        
            

    
        
            

        

<!-- SHOP SCREEN -->
<div id="shopScreen" class="hidden w-full max-w-4xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">SHOP</h2>
    
   <!-- Tab Navigation -->
<div class="flex gap-2 mb-6">
    <button id="tabUpgrades" class="game-btn px-6 py-3 text-sm bg-yellow-500 border-yellow-700 text-white">
        üõ†Ô∏è UPGRADES
    </button>
    <button id="tabSkins" class="game-btn px-6 py-3 text-sm bg-purple-500 border-purple-700 text-white">
        üé® SKINS
    </button>
    <button id="tabOutfits" class="game-btn px-6 py-3 text-sm bg-cyan-500 border-cyan-700 text-white">
        üëî OUTFITS
    </button>
</div>
    
    <!-- UPGRADES TAB CONTENT -->
    <div id="upgradesTab" class="tab-content">
        <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-6">
            <!-- Upgrade 1: Health -->
            <div class="shop-card">
                <div class="text-red-500 text-3xl">‚ô•</div>
                <h3 class="text-sm text-white mb-1">Iron Heart</h3>
                <p class="text-[10px] text-gray-400 mb-2">+20 Max HP</p>
                <p class="text-[10px] text-blue-300 mb-2">Level: <span id="lvlHealth">0</span></p>
                <button id="buyHealth" class="game-btn px-4 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600">
                    <span id="costHealth">100</span> G
                </button>
            </div>

            <!-- Upgrade 2: Magnet -->
            <div class="shop-card">
                <div class="text-blue-400 text-3xl">üß≤</div>
                <h3 class="text-sm text-white mb-1">Loot Magnet</h3>
                <p class="text-[10px] text-gray-400 mb-2">+20% Range</p>
                <p class="text-[10px] text-blue-300 mb-2">Level: <span id="lvlMagnet">0</span></p>
                <button id="buyMagnet" class="game-btn px-4 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600">
                    <span id="costMagnet">100</span> G
                </button>
            </div>

            <!-- Consumable: Turret -->
            <div class="shop-card border-gray-400">
                <div class="text-gray-300 text-3xl">üî´</div>
                <h3 class="text-sm text-white mb-1">Sentry</h3>
                <p class="text-[10px] text-gray-400 mb-2">Auto-Shooter</p>
                <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invTurret">0</span></p>
                <button id="buyTurret" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
                    <span id="txtTurretCost">40</span> G
                </button>
            </div>

            <!-- Consumable: Bomb -->
            <div class="shop-card border-gray-400">
                <div class="text-orange-500 text-3xl">üí£</div>
                <h3 class="text-sm text-white mb-1">Bomb</h3>
                <p class="text-[10px] text-gray-400 mb-2">AOE Explosion</p>
                <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invBomb">0</span></p>
                <button id="buyBomb" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
                    <span id="txtBombCost">30</span> G
                </button>
            </div>
        </div>
    </div>
    
    <!-- SKINS TAB CONTENT -->
    <div id="skinsTab" class="tab-content hidden">
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-6 mb-6">
            <!-- Golden Skin -->
            <div class="shop-card border-yellow-500 bg-gradient-to-br from-yellow-900 to-gray-900">
                <div class="text-yellow-300 text-5xl mb-3 animate-pulse">‚òÖ</div>
                <h3 class="text-lg text-yellow-300 mb-2 font-bold">Golden Hero</h3>
                <p class="text-[10px] text-gray-300 mb-3">Shine like a champion! Golden glow for all heroes.</p>
                <div class="flex flex-col gap-2 mb-3">
                    <div class="flex gap-1 justify-center">
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                    </div>
                </div>
<p class="text-[10px] text-blue-300 mb-3" id="statusSkin">Locked</p>
<button id="buySkin" class="game-btn px-4 py-3 text-sm w-full bg-gradient-to-r from-yellow-500 to-yellow-600 border-yellow-700 text-white font-bold">
    üí∞ 500 G
</button>
<button id="unequipSkin" class="game-btn px-4 py-3 text-sm w-full bg-red-500 border-red-700 text-white font-bold hidden mt-2">
    UNEQUIP
</button>
            </div>
        
            
            <!-- Obsidian Knight Skin -->
<div class="shop-card border-purple-600 bg-gradient-to-br from-purple-900 to-gray-900">
    <div class="relative mb-3">
        <div class="text-purple-400 text-5xl mb-3 animate-pulse">üíé</div>
        <div class="absolute -top-2 -right-2 bg-purple-600 text-white text-[8px] px-2 py-1 rounded-full font-bold animate-bounce">LEGENDARY!</div>
    </div>
    <h3 class="text-lg text-purple-300 mb-2 font-bold">Obsidian Warrior</h3>
    <p class="text-[10px] text-gray-300 mb-3">Dark armor forged in obsidian runes</p>
    <div class="flex flex-col gap-2 mb-3">
        <div class="flex gap-1 justify-center">
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
        </div>
    </div>
    <p class="text-[10px] text-blue-300 mb-3" id="statusObsidianSkin">Locked</p>
    <button id="buyObsidianSkin" class="game-btn px-4 py-3 text-sm w-full bg-gradient-to-r from-purple-600 to-purple-800 border-purple-900 text-white font-bold">
        üíé 1500 G
    </button>
    <button id="unequipObsidianSkin" class="game-btn px-4 py-3 text-sm w-full bg-red-500 border-red-700 text-white font-bold hidden mt-2">
        UNEQUIP
    </button>
</div>
        </div>
   </div>

<!-- OUTFITS TAB CONTENT -->
<div id="outfitsTab" class="tab-content hidden">
    <div class="mb-4 text-xs text-gray-400">Mix and match your cosmetics! (One hat + one accessory max)</div>
    
    <div class="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6">
       <!-- HATS SECTION -->
<div class="bg-gray-800 p-4 rounded-lg border-2 border-cyan-500 max-h-96 overflow-y-auto">
    <h3 class="text-sm text-cyan-300 mb-3 font-bold">üé© HATS (Choose One)</h3>
    
    <!-- Royal Crown -->
    <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="text-2xl">üëë</div>
                <div>
                    <h4 class="text-xs text-yellow-400">Royal Crown</h4>
                    <p class="text-[8px] text-gray-400" id="crownStatus">Locked</p>
                </div>
            </div>
            <div class="flex flex-col gap-1">
                <button id="toggleCrown" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
                <button id="buyCrown" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                    1000G
                </button>
            </div>
        </div>
    </div>
    
    <!-- Santa Hat -->
    <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="text-2xl">üéÖ</div>
                <div>
                    <h4 class="text-xs text-red-400">Santa Hat</h4>
                    <p class="text-[8px] text-gray-400" id="santaHatStatus">Locked</p>
                </div>
            </div>
            <button id="toggleSantaHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                LOCKED
            </button>
        </div>
    </div>
    
    <!-- Elf Hat -->
    <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="text-2xl">üßù</div>
                <div>
                    <h4 class="text-xs text-green-400">Elf Hat</h4>
                    <p class="text-[8px] text-gray-400" id="elfHatStatus">Locked</p>
                </div>
            </div>
            <button id="toggleElfHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                LOCKED
            </button>
        </div>
    </div>
    
    <!-- Antlers -->
    <div class="bg-gray-900 p-3 rounded border-2 border-gray-700">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="text-2xl">ü¶å</div>
                <div>
                    <h4 class="text-xs text-orange-400">Antlers</h4>
                    <p class="text-[8px] text-gray-400" id="antlersStatus">Locked</p>
                </div>
            </div>
            <button id="toggleAntlers" class="game-btn px-3 py-1 text-[10px]" disabled>
                LOCKED
            </button>
        </div>
    </div>
</div>
        
        <!-- ACCESSORIES SECTION -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-purple-500">
            <h3 class="text-sm text-purple-300 mb-3 font-bold">‚ú® ACCESSORIES</h3>
            
            <!-- Carrot Nose -->
            <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div class="text-2xl">‚õÑ</div>
                        <div>
                            <h4 class="text-xs text-orange-300">Carrot Nose</h4>
                            <p class="text-[8px] text-gray-400" id="carrotStatus">Locked</p>
                        </div>
                    </div>
                    <button id="toggleCarrot" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                </div>
            </div>
            
            <!-- Coming Soon -->
            <div class="bg-gray-900 p-3 rounded border-2 border-gray-700 opacity-50">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div class="text-2xl">üîí</div>
                        <div>
                            <h4 class="text-xs text-gray-500">More Soon...</h4>
                            <p class="text-[8px] text-gray-600">Future Update</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<button id="btnBackFromShop" class="game-btn px-6 py-2 text-sm w-full mt-4">BACK</button>
</div>

<!-- MULTIPLAYER SCREEN -->
<div id="multiplayerScreen" class="hidden w-full max-w-2xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-purple-700">
<h2 class="text-xl text-blue-400 mb-6 border-b-4 border-blue-400 pb-2 inline-block">ü§ù CO-OP MODE</h2>
    
    <!-- Room Creation/Join Section -->
    <div id="roomLobby" class="mb-6">
        <div class="bg-gray-800 p-4 rounded-lg mb-4">
            <h3 class="text-white text-sm mb-3">Create Room</h3>
            <button id="btnCreateRoom" class="game-btn px-6 py-3 text-sm w-full bg-green-500 border-green-700 text-white">
                üéÆ CREATE ROOM
            </button>
        </div>
        
        <div class="bg-gray-800 p-4 rounded-lg">
            <h3 class="text-white text-sm mb-3">Join Room</h3>
<input 
    type="text" 
    id="roomCodeInput" 
    placeholder="Enter Room Code..."
    class="w-full px-4 py-2 bg-gray-900 text-white text-sm border border-gray-600 rounded mb-3 uppercase"
    maxlength="6"
    oninput="this.value = this.value.toUpperCase()"
>
            <button id="btnJoinRoom" class="game-btn px-6 py-3 text-sm w-full bg-blue-500 border-blue-700 text-white">
                üö™ JOIN ROOM
            </button>
        </div>
    </div>
    
    <!-- Room Display (shown when in a room) -->
    <div id="roomDisplay" class="hidden">
        <div class="bg-gradient-to-r from-purple-900 to-blue-900 p-6 rounded-lg mb-4 text-center border-2 border-yellow-400">
            <h3 class="text-yellow-300 text-sm mb-2">ROOM CODE</h3>
            <div id="displayRoomCode" class="text-5xl font-bold text-white mb-2">ABCD12</div>
            <p class="text-gray-300 text-xs">Share this code with your friend!</p>
        </div>
        
        <div class="bg-gray-800 p-4 rounded-lg mb-4">
            <h3 class="text-white text-sm mb-3">Players in Room</h3>
            <div id="playersList" class="space-y-2">
                <!-- Players will be listed here -->
            </div>
        </div>
        
        <div class="text-center text-yellow-400 text-sm mb-4" id="waitingText">
    Waiting for teammate...
</div>
        
<button id="btnStartMatch" class="game-btn px-8 py-4 text-lg w-full bg-green-500 border-green-700 text-white hidden">
    üéÆ START CO-OP
</button>
        
        <button id="btnLeaveRoom" class="game-btn px-6 py-3 text-sm w-full bg-red-500 border-red-700 text-white mt-4">
            üö™ LEAVE ROOM
        </button>
    </div>
    
    <button id="btnBackFromMultiplayer" class="game-btn px-6 py-3 text-sm w-full mt-4">BACK TO MENU</button>
</div>

<!-- STATS SCREEN -->
<div id="statsScreen" class="hidden w-full max-w-2xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-4 border-b-4 border-yellow-400 pb-2 inline-block">CAREER STATS</h2>
    
    <!-- Top 3 Heroes Podium - COMPACT VERSION -->
    <div class="bg-gradient-to-b from-gray-800 to-gray-900 p-4 rounded-lg mb-4 border-2 border-yellow-600">
        <h3 class="text-left text-yellow-300 text-xs mb-3 font-bold">üèÜ TOP HEROES üèÜ</h3>
        <div class="flex items-end justify-center gap-3 h-36">
            <!-- 2nd Place -->
            <div class="flex flex-col items-center" id="podium2nd">
                <div class="text-center mb-1">
                    <div id="hero2ndBlock" class="w-12 h-12 mx-auto mb-1 border-2 border-gray-400 shadow-lg"></div>
                    <div id="hero2ndName" class="text-[8px] text-gray-300 font-bold">---</div>
                    <div id="hero2ndKills" class="text-xs text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-20 h-20 bg-gradient-to-b from-gray-400 to-gray-600 border-4 border-gray-500 flex items-center justify-center">
                        <span class="text-3xl font-bold text-white">2</span>
                    </div>
                    <div class="absolute -top-2 -right-2 text-xl">ü•à</div>
                </div>
            </div>
            
            <!-- 1st Place -->
            <div class="flex flex-col items-center" id="podium1st">
                <div class="text-center mb-1">
                    <div id="hero1stBlock" class="w-14 h-14 mx-auto mb-1 border-4 border-yellow-400 shadow-2xl"></div>
                    <div id="hero1stName" class="text-[9px] text-yellow-300 font-bold">---</div>
                    <div id="hero1stKills" class="text-sm text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-24 h-28 bg-gradient-to-b from-yellow-400 to-yellow-600 border-4 border-yellow-500 flex items-center justify-center">
                        <span class="text-4xl font-bold text-white">1</span>
                    </div>
                    <div class="absolute -top-2 -right-2 text-2xl animate-bounce">üëë</div>
                </div>
            </div>
            
            <!-- 3rd Place -->
            <div class="flex flex-col items-center" id="podium3rd">
                <div class="text-center mb-1">
                    <div id="hero3rdBlock" class="w-10 h-10 mx-auto mb-1 border-2 border-orange-600 shadow-md"></div>
                    <div id="hero3rdName" class="text-[8px] text-gray-400 font-bold">---</div>
                    <div id="hero3rdKills" class="text-[10px] text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-16 h-16 bg-gradient-to-b from-orange-600 to-orange-800 border-4 border-orange-700 flex items-center justify-center">
                        <span class="text-2xl font-bold text-white">3</span>
                    </div>
                    <div class="absolute -top-1 -right-1 text-lg">ü•â</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Overall Stats -->
    <div class="flex flex-col gap-2 text-sm mb-6">
        <div class="stat-row">
            <span class="text-gray-400">Best Wave</span>
            <span id="statBestWave" class="text-yellow-300">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Total Kills</span>
            <span id="statTotalKills" class="text-white">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Total Deaths</span>
            <span id="statTotalDeaths" class="text-white">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Highest Level</span>
            <span id="statBestLevel" class="text-blue-400">1</span>
        </div>
    </div>
    <button id="btnBackFromStats" class="game-btn px-6 py-2 text-sm w-full">BACK</button>
</div>

<!-- SETTINGS SCREEN -->
<div id="settingsScreen" class="hidden w-full max-w-md mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">SETTINGS</h2>

    <div class="bg-gray-800 p-4 rounded mb-4">
    <h3 class="text-white text-sm mb-3">üéÑ Theme</h3>
    <div class="flex items-center justify-between">
        <span class="text-gray-400 text-xs">Christmas Mode</span>
        <button id="christmasToggle" class="game-btn px-4 py-2 text-xs bg-red-500 border-red-700 text-white">
            OFF
        </button>
    </div>
</div>
    
    <div class="bg-gray-800 p-4 rounded mb-4">
        <h3 class="text-white text-sm mb-3">üéµ Audio</h3>
        <div class="flex items-center justify-between">
            <span class="text-gray-400 text-xs">Background Music</span>
            <button id="musicToggle" class="game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white">
                ON
            </button>
        </div>
    </div>
    
<div class="text-[10px] text-gray-400 space-y-1">
    <p>WASD / Arrows - Move</p>
    <p>Mouse - Aim & Shoot</p>
    <p>SPACE - Dash</p>
    <p>V - Special Ability</p>
    <p>T - Deploy Turret</p>
    <p>B - Use Bomb</p>
    <p>C - Tempest Ability</p>
    <p>Q - Switch Weapon (Knight/Unit-7)</p>
</div>
    </div>
    
    <button id="btnBackFromSettings" class="game-btn px-6 py-2 text-sm w-full mt-4" style="display: none;">BACK</button>
</div>

<!-- CHRISTMAS SCREEN -->
<!-- CHRISTMAS SCREEN -->
<div id="christmasScreen" class="hidden w-full max-w-4xl mx-auto bg-gradient-to-br from-red-900 via-green-900 to-red-900 p-8 rounded-lg border-4 border-yellow-400 shadow-2xl relative overflow-y-auto max-h-[85vh]">
    <!-- Animated Christmas Lights Border -->
    <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-red-500 via-green-500 to-red-500 animate-pulse"></div>
    
    <h2 class="text-3xl text-yellow-300 mb-2 text-center font-bold tracking-wider">üéÖ CHRISTMAS EVENT üéÑ</h2>
    <p class="text-[10px] text-gray-300 text-center mb-6">Limited Time Holiday Celebration!</p>
    
    <!-- Snowflake Currency Display -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 text-center border-2 border-cyan-400">
        <div class="text-sm text-gray-400 mb-2">YOUR SNOWFLAKES</div>
        <div class="flex items-center justify-center gap-3">
            <div class="text-5xl">‚ùÑÔ∏è</div>
            <span id="snowflakeCount" class="text-5xl font-bold text-cyan-300">0</span>
        </div>
        <p class="text-xs text-gray-400 mt-2">Collect snowflakes from defeated enemies!</p>
    </div>
    
    <!-- Present Opening Section -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 border-2 border-yellow-400">
        <h3 class="text-xl text-yellow-300 mb-4 text-center font-bold">üéÅ MYSTERY PRESENTS</h3>
        <p class="text-xs text-gray-300 text-center mb-4">Open presents for amazing rewards!</p>
        
        <div class="grid grid-cols-3 gap-4 mb-6">
            <!-- Basic Present -->
            <div class="bg-gradient-to-b from-green-600 to-green-800 p-4 rounded-lg border-2 border-green-400 text-center">
                <div class="text-4xl mb-2">üéÅ</div>
                <h4 class="text-sm text-white mb-2">Basic Gift</h4>
                <p class="text-[10px] text-gray-200 mb-3">Small surprise!</p>
                <button id="buyBasicPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-green-500 border-green-700 text-white">
                    10 ‚ùÑÔ∏è
                </button>
            </div>
            
            <!-- Premium Present -->
            <div class="bg-gradient-to-b from-red-600 to-red-800 p-4 rounded-lg border-2 border-red-400 text-center">
                <div class="text-4xl mb-2 animate-bounce">üéÅ</div>
                <h4 class="text-sm text-yellow-300 mb-2">Premium Gift</h4>
                <p class="text-[10px] text-gray-200 mb-3">Better rewards!</p>
                <button id="buyPremiumPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-red-500 border-red-700 text-white">
                    25 ‚ùÑÔ∏è
                </button>
            </div>
            
            <!-- Legendary Present -->
            <div class="bg-gradient-to-b from-yellow-500 to-yellow-700 p-4 rounded-lg border-2 border-yellow-300 text-center relative">
                <div class="absolute -top-2 -right-2 bg-red-600 text-white text-[8px] px-2 py-1 rounded-full font-bold">RARE!</div>
                <div class="text-4xl mb-2 animate-pulse">üéÅ</div>
                <h4 class="text-sm text-white mb-2">Legendary Gift</h4>
                <p class="text-[10px] text-gray-900 mb-3">Epic loot!</p>
                <button id="buyLegendaryPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600 text-black font-bold">
                    50 ‚ùÑÔ∏è
                </button>
            </div>
        </div>
        
        <!-- Reward Display -->
        <div id="presentReward" class="hidden bg-green-900 border-2 border-green-400 rounded-lg p-4 text-center">
            <p id="rewardText" class="text-lg text-yellow-300 font-bold"></p>
        </div>
    </div>
    
   <!-- What You Can Get -->
<div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 border-2 border-purple-400">
    <h3 class="text-xl text-purple-300 mb-4 text-center font-bold">üéÅ POSSIBLE REWARDS</h3>
    <p class="text-xs text-gray-300 text-center mb-4">Open presents to unlock these cosmetics!</p>
    
    <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
        <!-- Santa Hat -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">üéÖ</div>
            <h4 class="text-xs text-red-400">Santa Hat</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="santaHatPreview">Locked</p>
        </div>
        
        <!-- Elf Hat -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">üßù</div>
            <h4 class="text-xs text-green-400">Elf Hat</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="elfHatPreview">Locked</p>
        </div>
        
        <!-- Reindeer Antlers -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">ü¶å</div>
            <h4 class="text-xs text-orange-400">Antlers</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="antlersPreview">Locked</p>
        </div>
        
        <!-- Carrot Nose -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">‚õÑ</div>
            <h4 class="text-xs text-orange-300">Carrot Nose</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="carrotPreview">Locked</p>
        </div>
    </div>
    
    <p class="text-[10px] text-cyan-300 text-center mt-4">üí° Equip these in the Shop ‚Üí Outfits tab!</p>
</div>

    
    <button id="btnBackFromChristmas" class="game-btn px-8 py-4 text-lg w-full bg-red-600 border-red-800 text-white hover:bg-red-500 shadow-xl mt-4">
    ‚¨ÖÔ∏è BACK TO MENU
</button>
    <!-- Christmas Snow Effect Styles -->
<style>
    @keyframes snowfall {
        0% { transform: translateY(-10px) rotate(0deg); }
        100% { transform: translateY(100vh) rotate(360deg); }
    }
    .snowflake {
        position: fixed;
        top: -20px;
        color: white;
        font-size: 20px;
        opacity: 0.8;
        pointer-events: none;
        z-index: 9999;
        animation: snowfall linear infinite;
    }
</style>
</div>

<!-- MORE SCREEN -->
<div id="moreScreen" class="hidden w-full max-w-md mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">MORE OPTIONS</h2>
    
    <div class="grid grid-cols-1 gap-4">
        <button id="btnSettingsMore" class="game-btn px-6 py-4 text-md w-full bg-gray-600 border-gray-800 text-white hover:bg-gray-500">
            ‚öôÔ∏è SETTINGS
        </button>
        <button id="btnPerksMore" class="game-btn px-6 py-4 text-md w-full bg-cyan-500 border-cyan-700 text-white hover:bg-cyan-400">
            ‚≠ê PERKS
        </button>
        <button id="btnChristmasMore" class="game-btn px-6 py-4 text-md w-full bg-red-600 border-red-800 text-white hover:bg-red-500 animate-pulse">
            üéÑ CHRISTMAS
        </button>
<button id="btnCoopMore" class="game-btn px-6 py-4 text-md w-full bg-blue-500 border-blue-700 text-white hover:bg-blue-400">
    ü§ù CO-OP MODE
</button>
    </div>
    
    <button id="btnBackFromMore" class="game-btn px-6 py-2 text-sm w-full mt-6">BACK</button>
</div>

<!-- PERKS SCREEN -->
<div id="perksScreen" class="hidden w-full max-w-2xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">HERO PERKS</h2>
    
    <div class="mb-4 text-xs text-gray-400">Unlock powerful special abilities! Press [V] in-game to activate.</div>
    
    <!-- Knight Perk -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-blue-500">
        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div class="flex-1">
                <h3 class="text-blue-300 text-sm mb-2">‚öîÔ∏è KNIGHT - Blade Storm</h3>
                <p class="text-[10px] text-gray-400 mb-2">Spin in a devastating circle, dealing massive damage to all nearby enemies.</p>
                <div class="flex items-center gap-4 text-[10px]">
                    <span class="text-red-400">Damage: 10</span>
                    <span class="text-yellow-400">Range: 120px</span>
                    <span class="text-cyan-400">Cooldown: 12s</span>
                </div>
            </div>
            <button id="btnKnightPerk" class="game-btn px-4 py-2 text-xs bg-blue-500 border-blue-700 text-white">
                UNLOCK<br>2500G
            </button>
        </div>
        <div id="knightPerkStatus" class="text-[10px] text-gray-500 mt-2">Status: Locked</div>
    </div>
    
    <!-- Archer Perk -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-green-500">
        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div class="flex-1">
                <h3 class="text-green-300 text-sm mb-2">üèπ ARCHER - Ricochet Shot</h3>
                <p class="text-[10px] text-gray-400 mb-2">Next shot shoots 6 arrows that bounce off walls and pierce enemies for 5 seconds!</p>
                <div class="flex items-center gap-4 text-[10px]">
                    <span class="text-yellow-400">Duration: 5s</span>
                    <span class="text-cyan-400">Cooldown: 22s</span>
                    <span class="text-purple-400">Max Bounces: 8</span>
                </div>
            </div>
            <button id="btnArcherPerk" class="game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white">
                UNLOCK<br>2500G
            </button>
        </div>
        <div id="archerPerkStatus" class="text-[10px] text-gray-500 mt-2">Status: Locked</div>
    </div>
    
    <!-- Placeholder for future perks -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-gray-600 opacity-50">
        <div class="text-center text-gray-600 text-sm py-4">
            üîí More Hero Perks Coming Soon...
        </div>
    </div>
    
    <button id="btnBackFromPerks" class="game-btn px-6 py-2 text-sm w-full">BACK</button>
</div>
<!-- PAC RANKING SCREEN -->
<div id="pacRankScreen" class="hidden w-full max-w-3xl mx-auto bg-gradient-to-br from-purple-900 via-gray-900 to-purple-900 p-8 rounded-lg border-4 border-purple-500 shadow-2xl">
    <h2 class="text-2xl text-purple-300 mb-2 text-center font-bold tracking-wider">‚ö° PAC SYSTEM ‚ö°</h2>
    <p class="text-[10px] text-gray-400 text-center mb-6">Performance Analyzed Coins</p>
    
    <!-- Current Rank Display -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 text-center border-2 border-purple-500">
        <div class="text-sm text-gray-400 mb-2">CURRENT RANK</div>
        <div id="pacCurrentRank" class="text-5xl font-bold text-purple-400 mb-2 uppercase tracking-widest">ROOKIE</div>
        <div id="pacCurrentRankIcon" class="text-6xl mb-2">üéñÔ∏è</div>
        <div class="flex items-center justify-center gap-3">
            <div class="w-8 h-8 bg-purple-400 rounded-full border-2 border-white animate-pulse"></div>
            <span id="pacCoinsDisplay" class="text-3xl font-bold text-purple-300">0</span>
            <span class="text-sm text-gray-400">PAC</span>
        </div>
    </div>
    
    <!-- Progress Track -->
    <div class="mb-8">
        <div class="flex justify-between text-xs text-gray-400 mb-2">
            <span id="pacProgressLabel">Next: FIGHTER</span>
            <span id="pacProgressText">0 / 500 PAC</span>
        </div>
        <div class="w-full h-6 bg-gray-800 border-2 border-purple-600 rounded-full overflow-hidden relative">
            <div id="pacProgressBar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-500" style="width: 0%"></div>
            <div class="absolute inset-0 flex items-center justify-center text-white text-xs font-bold drop-shadow-lg">
                <span id="pacProgressPercent">0%</span>
            </div>
        </div>
    </div>
    
    <!-- Rank Milestones -->
    <div class="grid grid-cols-5 gap-2 mb-6">
        <!-- Rookie -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600" id="rank-rookie">
            <div class="text-2xl mb-1">üéñÔ∏è</div>
            <div class="text-[10px] text-gray-400 font-bold">ROOKIE</div>
            <div class="text-[8px] text-gray-500">0 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-gray-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Fighter -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-fighter">
            <div class="text-2xl mb-1">ü•ä</div>
            <div class="text-[10px] text-red-400 font-bold">FIGHTER</div>
            <div class="text-[8px] text-gray-500">800 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-red-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Challenger -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-challenger">
            <div class="text-2xl mb-1">‚öîÔ∏è</div>
            <div class="text-[10px] text-blue-400 font-bold">CHALLENGER</div>
            <div class="text-[8px] text-gray-500">2500 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-blue-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Elite -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-elite">
            <div class="text-2xl mb-1">üëë</div>
            <div class="text-[10px] text-purple-400 font-bold">ELITE</div>
            <div class="text-[8px] text-gray-500">6000 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-purple-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-legend">
            <div class="text-2xl mb-1">üèÜ</div>
            <div class="text-[10px] text-yellow-400 font-bold">LEGEND</div>
            <div class="text-[8px] text-gray-500">10000 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-yellow-500 rounded" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <!-- Rank Benefits -->
    <div class="bg-black bg-opacity-60 p-4 rounded-lg mb-6 border-2 border-purple-500">
        <h3 class="text-sm text-purple-300 mb-3 font-bold">‚ú® CURRENT BENEFITS</h3>
        <div id="pacBenefits" class="text-xs text-gray-300 space-y-1">
            <p>üå´Ô∏è Gray Mist Trail</p>
            <p>üìä Performance Tracking</p>
        </div>
    </div>
    
    <button id="btnBackFromPac" class="game-btn px-6 py-2 text-sm w-full bg-purple-600 border-purple-800 text-white">BACK TO MENU</button>
</div>



<!-- HERO SELECT SCREEN -->
<div id="heroSelectScreen" class="hidden flex flex-col items-center w-full max-w-4xl mx-auto">
    <h2 class="text-sm sm:text-xl text-gray-300 mb-4">SELECT YOUR HERO</h2>
    
    <!-- Scrollable container with fixed height -->
    <div class="w-full max-w-2xl mb-8 overflow-y-auto" style="max-height: 60vh;">
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 px-4 pb-4">
            <!-- Knight -->
            <button class="char-select-card p-4 sm:p-6" data-type="knight">
                <div class="char-block bg-blue-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-blue-300 mb-2">Knight</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Wide Cleave</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">High HP</p>
            </button>
            
            <!-- Mage -->
            <button class="char-select-card p-4 sm:p-6" data-type="mage">
                <div class="char-block bg-red-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-red-300 mb-2">Mage</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Explosive AOE</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">High Dmg</p>
            </button>
            
            <!-- Archer -->
            <button class="char-select-card p-4 sm:p-6" data-type="archer">
                <div class="char-block bg-green-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-green-300 mb-2">Archer</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Machine Gun</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Fast Fire</p>
            </button>
            
            <!-- Ninja -->
            <button class="char-select-card p-4 sm:p-6" data-type="ninja">
                <div class="char-block bg-black mx-auto relative">
                    <div class="absolute top-2 left-0 w-full h-3 bg-red-600"></div>
                </div>
                <h3 class="text-xs sm:text-md text-gray-300 mb-2">Ninja</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Shuriken Storm</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Double Dash</p>
            </button>
            
            <!-- Tempest -->
            <button class="char-select-card p-4 sm:p-6" data-type="tempest">
                <div class="char-block bg-gray-300 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-2xl">üå™Ô∏è</div>
                </div>
                <h3 class="text-xs sm:text-md text-gray-300 mb-2">Tempest</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Wind Boomerangs</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Fury Wave</p>
            </button>
            
            <!-- Zap (LOCKED - Legend Rank) -->
            <button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="zap" id="zapCard">
                <div class="char-block bg-gradient-to-br from-yellow-400 to-blue-500 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-3xl">‚ö°</div>
                    <div class="absolute top-0 right-0 text-2xl">üîí</div>
                </div>
                <h3 class="text-xs sm:text-md text-yellow-300 mb-2">Zap</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Chain Lightning</p>
                <p class="text-[8px] sm:text-[10px] text-red-500 mt-1">Legend Rank</p>
            </button>
            
            <!-- Unit-7 (LOCKED - Elite Rank) -->
            <button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="unit7" id="unit7Card">
                <div class="char-block bg-gradient-to-br from-blue-400 to-gray-600 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-3xl">ü§ñ</div>
                    <div class="absolute top-0 right-0 text-2xl">üîí</div>
                </div>
                <h3 class="text-xs sm:text-md text-blue-300 mb-2">Unit-7</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Dual-Core</p>
                <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Elite Rank</p>
            </button>
        </div>
    </div>

    <button id="btnBackFromSelect" class="text-gray-500 hover:text-white text-xs underline mt-4">Back to Menu</button>
</div>
        <!-- Game UI Overlay (Hidden by default) -->
<div id="gameUI" class="hidden w-full absolute top-0 left-0 pointer-events-none flex flex-col gap-2 z-10 h-full">
    <!-- Top Bar -->
    <div class="flex justify-between items-start px-4 text-white drop-shadow-lg w-full mt-3">
        <div class="text-left bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-gray-700">
            <!-- ENHANCED: Much Larger Wave Text with better contrast -->
            <div class="text-base sm:text-lg text-gray-300 font-bold">WAVE</div>
            <div id="waveDisplay" class="text-yellow-400 text-5xl font-bold wave-anim leading-none">1</div>
            <div class="text-sm text-gray-400 font-bold mt-1" id="waveTimer">Next: 30s</div>
        </div>
        
        <!-- In-Game Coin Count -->
        <div class="flex flex-col items-center">
            <div class="flex items-center gap-3 bg-black bg-opacity-70 px-5 py-3 rounded-lg border-2 border-yellow-500 shadow-lg">
                <div class="w-6 h-6 bg-yellow-400 rounded-full border-2 border-white"></div>
                <!-- ENHANCED: Much Larger Coin Text -->
                <span id="gameCoins" class="text-yellow-300 text-2xl font-bold">0</span>
            </div>
            <!-- ENHANCED: Larger Dash Indicators -->
            <div id="dashIndicator" class="text-sm text-cyan-400 mt-2 font-bold hidden bg-black bg-opacity-60 px-3 py-1 rounded">‚ö° DASH READY</div>
            <div id="doubleDashIndicator" class="text-sm text-red-400 mt-2 font-bold hidden bg-black bg-opacity-60 px-3 py-1 rounded">‚ö°‚ö° DOUBLE DASH</div>
            <!-- Tempest Fury Bar -->
<div id="furyBarContainer" class="hidden mt-2 w-32">
    <div class="text-[10px] text-cyan-300 text-center mb-1">FURY</div>
    <div class="w-full h-3 bg-gray-800 border-2 border-cyan-400 rounded overflow-hidden">
        <div id="furyBarFill" class="h-full bg-gradient-to-r from-cyan-400 to-blue-500" style="width: 0%"></div>
    </div>
</div>
        </div>

        <div class="text-right bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-gray-700">
            <!-- ENHANCED: Much Larger Level Text -->
            <div class="text-base sm:text-lg text-gray-300 font-bold">LEVEL</div>
            <div id="levelDisplay" class="text-white text-5xl font-bold leading-none">1</div>
        </div>
    </div>
    <!-- LEFT SIDEBAR: Active Abilities -->
<div id="abilitySidebar" class="absolute left-2 top-24 flex flex-col gap-2 w-16 max-h-[70vh] overflow-y-auto">
    <!-- Abilities will be dynamically added here -->
</div>

<!-- Teammate HP Bar (Top Right) -->
<div id="teammateHpBar" class="hidden absolute top-24 right-4 bg-black bg-opacity-80 p-3 rounded-lg border-2 border-blue-500 w-48">
    <div class="text-xs text-blue-300 mb-1 font-bold">TEAMMATE</div>
    <div class="w-full h-4 bg-gray-800 border-2 border-blue-400 rounded overflow-hidden mb-1">
        <div id="teammateHpFill" class="h-full bg-gradient-to-r from-blue-400 to-blue-600" style="width: 100%"></div>
    </div>
    <div class="text-[10px] text-white text-center">
        <span id="teammateHpText">50/50</span>
    </div>
</div>

    <!-- Bottom Right: Skills -->
    <div class="absolute bottom-20 right-2 flex gap-2">
        <!-- Turret UI -->
        <div id="turretHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
            <div class="text-gray-300 text-2xl mb-1">üî´</div>
            <div class="text-sm text-white text-center font-bold">
                [T] <br> x<span id="hudTurretCount" class="text-green-400 font-bold text-lg">0</span>
            </div>
        </div>
        <!-- Bomb UI -->
        <div id="bombHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
            <div class="text-orange-500 text-2xl mb-1">üí£</div>
            <div class="text-sm text-white text-center font-bold">
                [B] <br> x<span id="hudBombCount" class="text-orange-400 font-bold text-lg">0</span>
            </div>
        </div>
    </div>
    
    <!-- XP Bar (Bottom) -->
    <div class="absolute bottom-2 left-0 px-4 w-full">
        <!-- ENHANCED: Much Larger HP & Kills with better backgrounds -->
        <div class="flex justify-between px-4 mt-1 text-lg font-bold pb-3">
            <span class="bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-red-500">
                <span class="text-red-400 drop-shadow-lg">‚ù§Ô∏è HP: <span id="hpDisplay" class="text-white text-xl">100/100</span></span>
            </span>
            <span class="bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-purple-500">
                <span class="text-gray-300 drop-shadow-lg">üíÄ Kills: <span id="kills" class="text-white text-xl">0</span></span>
            </span>
        </div>
        <div class="xp-container h-6 border-3">
            <div id="xpBar" class="xp-fill"></div>
            <div class="absolute inset-0 flex items-center justify-center text-xs text-white font-bold drop-shadow-lg">XP</div>
        </div>
    </div>
</div>

            <!-- Bottom Right: Skills -->
            <div class="absolute bottom-16 right-2 flex gap-2">
                <!-- Turret UI -->
                <div id="turretHud" class="hidden flex flex-col items-center bg-black bg-opacity-60 p-2 rounded border border-gray-500">
                    <div class="text-gray-300 text-xl mb-1">üî´</div>
                    <div class="text-xs text-white text-center">
                        [T] <br> x<span id="hudTurretCount" class="text-green-400 font-bold">0</span>
                    </div>
                </div>
                <!-- Bomb UI -->
                <div id="bombHud" class="hidden flex flex-col items-center bg-black bg-opacity-60 p-2 rounded border border-gray-500">
                    <div class="text-orange-500 text-xl mb-1">üí£</div>
                    <div class="text-xs text-white text-center">
                        [B] <br> x<span id="hudBombCount" class="text-orange-400 font-bold">0</span>
                    </div>
                </div>
            </div>
            

        <!-- Game Screen -->
        <div id="gameScreen" class="hidden relative flex justify-center">
            <canvas id="gameCanvas" width="800" height="600" style="width: 100%; height: auto;"></canvas>
            
            <!-- Wave Notification -->
            <div id="waveMsg" class="hidden absolute top-1/3 left-0 w-full text-center pointer-events-none z-20">
                <h2 id="waveMsgText" class="text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold">WAVE <span id="waveMsgNum">1</span></h2>
            </div>

            <!-- Level Up Notification -->
            <div id="levelUpMsg" class="hidden absolute top-1/4 left-0 w-full text-center pointer-events-none z-20">
            <!-- PAC Rank Up Notification -->
<div id="pacRankUpMsg" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50 pointer-events-none">
    <div class="text-center animate-bounce">
        <div class="text-6xl mb-4" id="pacRankUpIcon">üèÜ</div>
        <h2 class="text-5xl font-bold mb-2 bg-gradient-to-r from-purple-400 via-pink-500 to-purple-400 bg-clip-text text-transparent">
            RANK UP!
        </h2>
        <p class="text-3xl text-white font-bold mb-4" id="pacRankUpText">FIGHTER</p>
        <p class="text-lg text-gray-300">New trail unlocked!</p>
    </div>
</div>
                <h2 class="text-2xl sm:text-4xl text-yellow-300 drop-shadow-[0_4px_0_#000] animate-bounce">LEVEL UP!</h2>
                <p id="upgradeText" class="text-white text-xs sm:text-sm mt-2 bg-black bg-opacity-70 inline-block px-4 py-2 rounded border border-yellow-500">Damage Increased!</p>
            </div>
        </div>

<!-- Upgrade Selection Screen -->
<div id="upgradeScreen" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-95 z-50">
    <div class="max-w-5xl w-full p-8">
        <div class="text-center mb-8">
            <h2 class="text-5xl text-yellow-400 font-bold mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)] animate-pulse">‚¨ÜÔ∏è LEVEL UP! ‚¨ÜÔ∏è</h2>
            <p class="text-lg text-cyan-300 mb-2">Choose Your Power</p>
            <p class="text-sm text-gray-400">Pick wisely - upgrades last this run only</p>
        </div>
        
        <div id="upgradeChoices" class="grid grid-cols-1 sm:grid-cols-3 gap-8 mb-8">
            <!-- Upgrade cards will be generated here -->
        </div>
        
        <div class="text-center text-xs text-gray-500 bg-gray-900 p-3 rounded-lg border border-gray-700">
            <p>üí° <span class="text-yellow-400">Red</span> = Offense | <span class="text-blue-400">Blue</span> = Defense | <span class="text-purple-400">Purple</span> = Utility</p>
        </div>
    </div>
</div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-95 z-50">
            <h2 class="text-3xl sm:text-5xl text-red-500 mb-2 drop-shadow-[4px_4px_0_#fff]">YOU DIED</h2>
            <p class="text-sm sm:text-xl text-gray-300 mb-8">Survived Wave: <span id="finalWave" class="text-yellow-400">1</span></p>
            
           <div class="grid grid-cols-3 gap-6 mb-8 text-left text-xs sm:text-sm bg-gray-900 p-6 rounded border border-gray-700">
    <div>
        <p class="text-gray-500 mb-1">Total Kills</p>
        <p id="finalKills" class="text-white text-xl">0</p>
    </div>
    <div>
        <p class="text-gray-500 mb-1">Coins Earned</p>
        <p id="finalCoins" class="text-yellow-400 text-xl">0</p>
    </div>
    <div>
        <p class="text-gray-500 mb-1">PAC Earned</p>
        <p id="finalPAC" class="text-purple-400 text-xl">0</p>
    </div>
</div>
            
            <button id="restartButton" class="game-btn px-8 py-4 text-lg bg-white border-gray-400">RETURN TO MENU</button>
        </div>
    </div>

    <script>

            document.addEventListener('DOMContentLoaded', () => {
    
   
    
    // =====================================================
    //  GAME CONFIGURATION - TWEAK THESE NUMBERS TO BALANCE
            
            // =====================================================
            //  GAME CONFIGURATION - TWEAK THESE NUMBERS TO BALANCE
            // =====================================================
            const GAME_CONFIG = {
                // --- PLAYER STATS ---
                PLAYER: {
                    BASE_SIZE: 28,
                    BASE_SPEED: 3.5,
                    BASE_HP: 100,
                    BASE_MAGNET: 100,
                    MAGNET_PER_UPGRADE: 30,
                    HP_PER_UPGRADE: 20,
                    DASH: {
                        COOLDOWN: 180, // 3 seconds (60 frames = 1s)
                        DURATION: 10,  // How long dash lasts
                        SPEED: 12,     // Dash velocity
                    }
                },

                // --- CLASS SPECIFIC STATS ---
                CLASSES: {
                    knight: {
                        color: '#2563eb',
                        hp_bonus: 50,       // Starts with 150 HP
                        damage_mult: 1.0,
                        fire_rate_mult: 0.65,
                        sword_length: 90,
                        sword_width: 15
                    },
                    mage: {
                        color: '#dc2626',
                        hp_bonus: 0,
                        damage_mult: 1.5,   // 50% more damage
                        fire_rate_mult: 0.8,
                        speed_mult: 0.8
                    },
                    archer: {
                        color: '#16a34a',
                        hp_bonus: 0,
                        damage_mult: 0.88,
                        fire_rate_mult: 1.0, // Shoots 10% faster
                        speed_mult: 1.15     // Moves 15% faster
                    },
                    //class NINJA
                    ninja: {
                        color: '#000000',
                        hp_bonus: -20,      // Slightly lower HP
                        damage_mult: 0.99,
                        fire_rate_mult: 1.8, // Very fast shurikens
                        speed_mult: 1.3,     // Very fast movement
                        canDoubleDash: true
                    },
                   
//class TEMPEST
tempest: {
    color: '#d1d5db',  // Light gray
    hp_bonus: 0,
    damage_mult: 1.2,
    fire_rate_mult: 0.7,
    speed_mult: 1.1,
    furyBarMax: 10  // Kills needed to fill fury bar
},
// NEW CLASS: ZAP (LEGEND RANK ONLY) - REWORKED FOR FUN
zap: {
    color: '#fbbf24',  // Yellow
    hp_bonus: -10,     // Slightly low HP (was -30)
    damage_mult: 0.9,  // Reduced base damage (was 1.0)
    fire_rate_mult: 1.0, // Faster shooting (was 1.2)
    speed_mult: 1.25,  // Fast but not crazy (was 1.4)
    chainRange: 120,   // Slightly reduced chain range (was 150)
    chargeCounter: 0,  // Tracks charge buildup
    maxCharge: 100,    // Max charge points
    requiresLegend: true
}
,
unit7: {
    color: '#60a5fa',  // Chrome blue
    hp_bonus: -15,     // Low HP (glass cannon)
    damage_mult: 1.0,
    fire_rate_mult: 1.0,
    speed_mult: 0.85,
    requiresElite: true,  // Unlocked at Elite rank
    // Weapon modes
    currentMode: 'laser',  // 'laser' or 'micro'
    laserCooldown: 0,
    microCooldown: 0,
    microAmmo: 15,
    microMaxAmmo: 15
}
                
                },
// --- SPECIAL DROPS ---
SPECIAL_DROPS: {
    GOLDEN_COIN: {
        value: 15,
        spawn_chance: 0.03, // 3% chance
        decay_time: 240, // 4 seconds before disappearing
        risk_radius: 150 // Enemies spawn near it
    },
    HEALTH_PACK: {
        heal_amount: 30,
        spawn_chance: 0.02, // 2% chance
        decay_time: 180
    }
},

                // --- ENEMY STATS ---
                ENEMIES: {
                    normal: {
                        hp: 5,
                        speed: 1.33,
                        xp: 1,
                        size: 24,
                        color: '#b91c1c',
                        spawn_wave: 1
                    },

                   ranger: {
    hp: 5,
    speed: 1.1,
    xp: 2,
    size: 24,
    color: '#eab308',
    spawn_wave: 1,
    spawn_chance: 0.25,
    shootRange: 250,
    shootCooldown: 150,
    projectileSpeed: 12,
    projectileSize: 12,
    projectileDamage: 4
},
                    brute: {
                        hp: 20,
                        speed: 0.9,
                        xp: 10,
                        size: 50,
                        color: '#7f1d1d',
                        spawn_wave: 3,
                        spawn_chance: 0.15
                    },
                    frosty: {
                        hp: 10,
                        speed: 1.8,
                        xp: 5,
                        size: 32,
                        color: '#06b6d4',
                        spawn_wave: 5,
                        spawn_chance: 0.30
                    },
                    boss: {
                        hp: 85,
                        speed: 1.5,
                        xp: 50,
                        size: 100,
                        color: '#581c87',
                        damage: 3
                    },
                    // NEW ELITE ENEMIES
                    elite_specter: {
                        hp: 10,
                        speed: 2.2,
                        xp: 15,
                        size: 28,
                        color: '#9333ea',
                        spawn_wave: 7,
                        spawn_chance: 0.08,
                        ability: 'phase',
                        abilityCooldown: 180
                    },
                    elite_tank: {
                        hp: 40,
                        speed: 0.8,
                        xp: 20,
                        size: 45,
                        color: '#1e40af',
                        spawn_wave: 6,
                        spawn_chance: 0.18,
                        ability: 'shield',
                        abilityCooldown: 300
                    },
                    elite_splitter: {
                        hp: 12,
                        speed: 1.6,
                        xp: 12,
                        size: 32,
                        color: '#15803d',
                        spawn_wave: 8,
                        spawn_chance: 0.18,
                        ability: 'split',
                        splitCount: 3
                    }
                },

               // --- WAVE & DIFFICULTY ---
WAVES: {
    DURATION: 30, // Seconds per wave
    HP_SCALING: 0.12, // REDUCED: Enemies get +12% HP per wave (was 20%)
    HP_SCALING_CAP: 3.0, // Caps at 3x HP (prevents infinite scaling)
    COIN_CHANCE_BASE: 0.2, // 20% drop chance
    COIN_CHANCE_SCALING: 0.02, // +2% per wave
},

           PROJECTILES: {
    fireball: { damage: 3, speed: 6, size: 16, knockback: 1, explosionRadius: 70 },
    arrow:    { damage: 1.5, speed: 10, size: 8, knockback: 6 }, 
    sword:    { damage: 6.5, knockback: 2 }, 
    turret:   { damage: 1.5, speed: 12, size: 6, knockback: 0 },
    shuriken: { damage: 0.6, speed: 15, size: 6, knockback: 1.0 },
    boomerang: { damage: 0.8, speed: 8, size: 12, knockback: 3, maxDistance: 200, curveRate: 0.08, bonusDamagePerCurve: 0.15 },
    lightning: { damage: 2.5, speed: 18, size: 10, knockback: 2, chainRange: 150, chainDamage: 0.5 }
    ,
corelaser: { damage: 15, speed: 25, size: 12, knockback: 8, pierce: true },
microburst: { damage: 0.8, speed: 14, size: 4, knockback: 0.5 }
},

                // --- TURRET ITEM ---
                TURRET: {
                    COST: 40, // UPDATED: Lowered cost
                    LIFETIME: 900, // 15 seconds
                    RANGE: 210,
                    FIRE_RATE: 90  // UPDATED: Slower fire rate
                },
                // --- BOMB ITEM ---
                BOMB: {
    COST: 100,
    DAMAGE: 20,
    RADIUS: 150,
},

                // --- SHOP COSTS ---
                SHOP: {
                    HEALTH_BASE: 150,
                    MAGNET_BASE: 100,
                    SKIN: 500
                },
                
                STORAGE_KEY: 'Blocky Legends'

                ,
MAPS: {
    forest: {
        name: 'Dark Forest',
        bgColor: '#0a2f0a',
        gridColor: '#1a4d1a',
        treeCount: 15,
        trees: [],
        enemyTint: '#2d5016'
    },
    desert: {
        name: 'Scorched Desert',
        bgColor: '#3d2817',
        gridColor: '#5d3d27',
        cactusCount: 12,
        cacti: [],
        enemyTint: '#8b4513'
    },
    ice: {
        name: 'Frozen Wasteland',
        bgColor: '#1a2a3a',
        gridColor: '#2a3f5f',
        crystalCount: 10,
        crystals: [],
        enemyTint: '#4a7c9e'
    },
    volcano: {
        name: 'Volcanic Crater',
        bgColor: '#2a0f0f',
        gridColor: '#4a1f1f',
        lavaPoolCount: 8,
        lavaPools: [],
        enemyTint: '#8b0000'
    },
   swamp: {
    name: 'Misty Swamp',
    bgColor: '#1a2618',
    gridColor: '#2a3628',
    fogDensity: 0.3,
    fogColor: 'rgba(200, 220, 200, 0.4)',
    treeCount: 12,
    trees: [],
    enemyTint: '#4a6e4a'
}
}
                ,
MULTIPLAYER: {
    COUNTDOWN_TIME: 3
}
            };

            // =====================================================
// TEMPORARY UPGRADE SYSTEM
// =====================================================
const UPGRADE_POOL = [
    // ========== OFFENSE ==========
    {
        id: 'fire_ring',
        name: 'Inferno Aura',
        icon: 'üî•',
        description: 'Blazing ring burns all enemies that dare get close',
        type: 'offense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.fireRing = (player.upgrades.fireRing || 0) + 1;
        }
    },
    {
        id: 'lightning_storm',
        name: 'Lightning Storm',
        icon: '‚ö°',
        description: 'Call down devastating lightning bolts on random enemies',
        type: 'offense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.lightningStorm = (player.upgrades.lightningStorm || 0) + 1;
        }
    },
    {
        id: 'attack_speed',
        name: 'Rapid Fire',
        icon: 'üèπ',
        description: '+15% attack speed',
        type: 'offense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.attackSpeed = (player.upgrades.attackSpeed || 0) + 1;
            player.fireRateMult *= 1.15;
        }
    },
    {
    id: 'stun_gun',
    name: 'Stun Gun',
    icon: '‚ö°',
    description: '8% chance to stun enemies for 2 seconds on hit',
    type: 'utility',
    maxStack: 3,
    inRotation: true,
    effect: (player, stacks) => {
        player.upgrades.stunGun = (player.upgrades.stunGun || 0) + 1;
    }
},
// ========== DEFENSE ==========
    
{
    id: 'regen_aura',
    name: 'Regeneration Aura',
    icon: 'üíö',
    description: 'Heal 2 HP every 3 seconds', // UPDATED: Was 3 HP/2s, now 2 HP/3s
    type: 'defense',
    maxStack: 5,
    inRotation: true,
    effect: (player, stacks) => {
        player.upgrades.regenAura = (player.upgrades.regenAura || 0) + 1;
        // Initialize regen timer if it doesn't exist
        if (!player.regenTimer) player.regenTimer = 0;
    }
},
{
    id: 'ice_barrier',
    name: 'Frost Aura',
    icon: '‚ùÑÔ∏è',
    description: 'Freeze and slow enemies near you by 40%', // UPDATED: Was 60%, now 40%
        type: 'defense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.iceBarrier = (player.upgrades.iceBarrier || 0) + 1;
        }
    },
    {
        id: 'max_health',
        name: 'Vitality Boost',
        icon: '‚ù§Ô∏è',
        description: '+25 Max HP and instant heal',
        type: 'defense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.maxHealth = (player.upgrades.maxHealth || 0) + 1;
            player.maxHp += 25;
            player.hp = Math.min(player.hp + 25, player.maxHp);
            player.updateUI();
        }
    },
    {
        id: 'lifesteal',
        name: 'Vampirism',
        icon: 'ü©∏',
        description: 'Heal 2 HP for every 25 damage dealt',
        type: 'defense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.lifesteal = (player.upgrades.lifesteal || 0) + 1;
        }
    },
{
    id: 'thorns',
    name: 'Thorn Armor',
    icon: 'üåµ',
    description: 'Reflect 15% damage back to attackers', // UPDATED: Was 40%, now 15%
        type: 'defense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.thorns = (player.upgrades.thorns || 0) + 1;
        }
    },
    
    // ========== UTILITY ==========
   {
        id: 'speed_boost',
        name: 'Lightning Step',
        icon: '‚ö°',
        description: 'Gain burst of speed after killing enemies',
        type: 'utility',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.speedBoost = (player.upgrades.speedBoost || 0) + 1;
        }
    },
    {
        id: 'move_speed',
        name: 'Swift Feet',
        icon: 'üëü',
        description: '+12% movement speed',
        type: 'utility',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.moveSpeed = (player.upgrades.moveSpeed || 0) + 1;
            player.speed *= 1.12;
        }
    },
{
    id: 'piercing_shots',
    name: 'Armor Piercer',
    icon: 'üéØ',
    description: 'Pierce through enemies, dealing 50% less damage per hit',
    type: 'utility',
    maxStack: 3,
    inRotation: true,
    effect: (player, stacks) => {
        player.upgrades.piercingShots = (player.upgrades.piercingShots || 0) + 1;
    }
},
];
            // =====================================================

            // --- UI Elements ---
const screens = {
    menu: document.getElementById('mainMenuScreen'),
    stats: document.getElementById('statsScreen'),
    shop: document.getElementById('shopScreen'),
    settings: document.getElementById('settingsScreen'),
    perks: document.getElementById('perksScreen'),
    hero: document.getElementById('heroSelectScreen'),
    game: document.getElementById('gameScreen'),
    gameOver: document.getElementById('gameOverScreen'),
    christmas: document.getElementById('christmasScreen'),
    more: document.getElementById('moreScreen')
};
            const gameTitle = document.getElementById('gameTitle');
            const gameUI = document.getElementById('gameUI');
            const coinDisplayMenu = document.getElementById('coinDisplayMenu');

            const ui = {
                menuCoins: document.getElementById('menuCoins'),
                gameCoins: document.getElementById('gameCoins'),
                dashInd: document.getElementById('dashIndicator'),
                doubleDashInd: document.getElementById('doubleDashIndicator'), // New UI for double dash
                turretHud: document.getElementById('turretHud'),
                hudTurretCount: document.getElementById('hudTurretCount'),
                bombHud: document.getElementById('bombHud'),
hudBombCount: document.getElementById('hudBombCount'),
                kills: document.getElementById('kills'),
                wave: document.getElementById('waveDisplay'),
                waveTimer: document.getElementById('waveTimer'),
                level: document.getElementById('levelDisplay'),
                xpBar: document.getElementById('xpBar'),
                hp: document.getElementById('hpDisplay'),
                waveMsg: document.getElementById('waveMsg'),
                waveMsgNum: document.getElementById('waveMsgNum'),
                levelUpMsg: document.getElementById('levelUpMsg'),
                upgradeText: document.getElementById('upgradeText'),
                // Shop UI
                lvlHealth: document.getElementById('lvlHealth'),
                costHealth: document.getElementById('costHealth'),
                btnHealth: document.getElementById('buyHealth'),
                lvlMagnet: document.getElementById('lvlMagnet'),
                costMagnet: document.getElementById('costMagnet'),
                btnMagnet: document.getElementById('buyMagnet'),
                invTurret: document.getElementById('invTurret'),
                btnTurret: document.getElementById('buyTurret'),
                txtTurretCost: document.getElementById('txtTurretCost'),
                invBomb: document.getElementById('invBomb'),
                btnBomb: document.getElementById('buyBomb'),
                txtBombCost: document.getElementById('txtBombCost'),
                statusSkin: document.getElementById('statusSkin'),
                btnSkin: document.getElementById('buySkin'),
                // Stats UI
                statBestWave: document.getElementById('statBestWave'),
                statTotalKills: document.getElementById('statTotalKills'),
                statTotalDeaths: document.getElementById('statTotalDeaths'),
                statBestLevel: document.getElementById('statBestLevel'),
                finalWave: document.getElementById('finalWave'),
                finalKills: document.getElementById('finalKills'),
                finalCoins: document.getElementById('finalCoins')
            };

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- SAVE DATA SYSTEM ---
let saveData = {
    coins: 0,
    snowflakes: 0, // NEW: Christmas currency
    stats: {
        kills: 0,
        deaths: 0,
        bestWave: 1,
        bestLevel: 1,
       heroKills: {
    knight: 0,
    mage: 0,
    archer: 0,
    ninja: 0,
    tempest: 0,
    zap: 0,
    unit7: 0
}
    },
    upgrades: {
    health: 0, 
    magnet: 0,
    goldSkin: false,
    obsidianSkin: false
},
    inventory: {
        turrets: 0,
        bombs: 0
    },
    redeemedCodes: [],
    perks: {
        knightBladestorm: false,
        archerRicochet: false
    },
    pac: {
        coins: 0,
        rank: 'rookie',
        trailColor: '#9ca3af'
    },
    christmasMode: false,
    // NEW: Christmas cosmetics
    cosmetics: {
    crown: { owned: false, equipped: false },
    santaHat: { owned: false, equipped: false },
    elfHat: { owned: false, equipped: false },
    antlers: { owned: false, equipped: false },
    carrotNose: { owned: false, equipped: false }
}
};
            function loadData() {
                const saved = localStorage.getItem(GAME_CONFIG.STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        saveData = { ...saveData, ...parsed }; 
                        if(parsed.stats) saveData.stats = { ...saveData.stats, ...parsed.stats };
                        if(parsed.upgrades) saveData.upgrades = { ...saveData.upgrades, ...parsed.upgrades };
                        if(parsed.inventory) saveData.inventory = { ...saveData.inventory, ...parsed.inventory };
                    if(parsed.perks) saveData.perks = { ...saveData.perks, ...parsed.perks };
                        if(parsed.pac) saveData.pac = { ...saveData.pac, ...parsed.pac };
                    } catch(e) { console.error("Save corrupt"); }
                }
                updateShopUI();
            }

            function saveDataToStorage() {
    try {
        // Deep clone to ensure no reference issues
        const dataToSave = JSON.parse(JSON.stringify(saveData));
        localStorage.setItem(GAME_CONFIG.STORAGE_KEY, JSON.stringify(dataToSave));
        updateShopUI();
        console.log('‚úÖ Game saved successfully');
    } catch (e) {
        console.error('‚ùå Failed to save game:', e);
    }
    // Apply Christmas mode if enabled
if (saveData.christmasMode) {
    applyChristmasMode();
}
}

// PAC Ranking system
const PAC_RANKS = {
    rookie: { name: 'ROOKIE', threshold: 0, icon: 'üéñÔ∏è', trail: '#9ca3af', next: 'fighter' },
    fighter: { threshold: 800, icon: 'ü•ä', trail: '#ef4444', next: 'challenger' },  // EASIER: Was 1000
    challenger: { threshold: 2500, icon: '‚öîÔ∏è', trail: '#3b82f6', next: 'elite' },  // EASIER: Was 3000
    elite: { threshold: 6000, icon: 'üëë', trail: '#a855f7', next: 'legend' },  // EASIER: Was 7000
    legend: { threshold: 10000, icon: 'üèÜ', trail: '#fbbf24', next: null }  // EASIER: Was 14000
};

function calculatePACCoins(waves, kills, timeAlive) {
    // No PAC rewards for dying on wave 1
    if (waves <= 1) {
        return 0;
    }
    
    // Heavily reduced rewards - only count waves PAST wave 1
    const waveScore = (waves - 1) * 15;  // Reduced from 50 to 15
    const killScore = Math.floor(kills * 0.5);  // Reduced from 2 to 0.5
    const timeScore = Math.floor(timeAlive / 120) * 3;  // Reduced from /60*10 to /120*3
    
    let multiplier = 1.0;
    if (waves >= 25) multiplier += 0.3;  // Harder to get bonuses
    if (kills >= 500) multiplier += 0.2;
    
    const total = Math.floor((waveScore + killScore + timeScore) * multiplier);
    return Math.max(total, 0);  // Can return 0 now
}

function updatePACRank(earnedPAC) {
    const oldRank = saveData.pac.rank;
    saveData.pac.coins += earnedPAC;
    
    let newRank = 'rookie';
    for (const [rank, data] of Object.entries(PAC_RANKS)) {
        if (saveData.pac.coins >= data.threshold) {
            newRank = rank;
        }
    }
    
    if (newRank !== oldRank) {
        saveData.pac.rank = newRank;
        saveData.pac.trailColor = PAC_RANKS[newRank].trail;
        showRankUpNotification(newRank);
    }
    
    updatePACUI();
    saveDataToStorage();
}

function showRankUpNotification(newRank) {
    const rankData = PAC_RANKS[newRank];
    const msg = document.getElementById('pacRankUpMsg');
    document.getElementById('pacRankUpIcon').textContent = rankData.icon;
    document.getElementById('pacRankUpText').textContent = newRank.toUpperCase();
    
    msg.classList.remove('hidden');
    setTimeout(() => msg.classList.add('hidden'), 4000);
}

function updatePACUI() {
    const rank = saveData.pac.rank;
    const rankData = PAC_RANKS[rank];
    const coins = saveData.pac.coins;
    
    document.getElementById('pacRankText').textContent = rank.toUpperCase();
    
    const pacCoinsDisplay = document.getElementById('pacCoinsDisplay');
    const pacCurrentRank = document.getElementById('pacCurrentRank');
    const pacCurrentRankIcon = document.getElementById('pacCurrentRankIcon');
    
    if (pacCoinsDisplay) pacCoinsDisplay.textContent = coins;
    if (pacCurrentRank) pacCurrentRank.textContent = rank.toUpperCase();
    if (pacCurrentRankIcon) pacCurrentRankIcon.textContent = rankData.icon;
    
    if (rankData.next) {
        const nextRankData = PAC_RANKS[rankData.next];
        const progress = coins - rankData.threshold;
        const required = nextRankData.threshold - rankData.threshold;
        const percent = Math.min(100, (progress / required) * 100);
        
        const progressBar = document.getElementById('pacProgressBar');
        const progressPercent = document.getElementById('pacProgressPercent');
        const progressLabel = document.getElementById('pacProgressLabel');
        const progressText = document.getElementById('pacProgressText');
        
        if (progressBar) progressBar.style.width = `${percent}%`;
        if (progressPercent) progressPercent.textContent = `${Math.floor(percent)}%`;
        if (progressLabel) progressLabel.textContent = `Next: ${rankData.next.toUpperCase()}`;
        if (progressText) progressText.textContent = `${coins} / ${nextRankData.threshold} PAC`;
    } else {
        const progressBar = document.getElementById('pacProgressBar');
        const progressPercent = document.getElementById('pacProgressPercent');
        const progressLabel = document.getElementById('pacProgressLabel');
        const progressText = document.getElementById('pacProgressText');
        
        if (progressBar) progressBar.style.width = '100%';
        if (progressPercent) progressPercent.textContent = 'MAX';
        if (progressLabel) progressLabel.textContent = 'MAX RANK';
        if (progressText) progressText.textContent = 'LEGEND STATUS';
    }
    
    for (const [rankName, data] of Object.entries(PAC_RANKS)) {
        const card = document.getElementById(`rank-${rankName}`);
        if (card) {
            if (coins >= data.threshold) {
                card.classList.remove('opacity-50');
                card.style.borderColor = rankName === rank ? '#a855f7' : '#4b5563';
            }
        }
    }
    
    const benefits = {
        rookie: ['üå´Ô∏è Gray Mist Trail', 'üìä Performance Tracking'],
        fighter: ['üî• Red Flame Trail', 'üí™ +5% Coin Bonus (Coming Soon)'],
        challenger: ['‚ùÑÔ∏è Blue Ice Trail', '‚ö° +10% XP Bonus (Coming Soon)'],
        elite: ['üëë Purple Royal Trail', 'üíé Exclusive Cosmetics (Coming Soon)'],
        legend: ['‚ú® Golden Glory Trail', 'üèÜ Ultimate Prestige']
    };
    
    const pacBenefits = document.getElementById('pacBenefits');
    if (pacBenefits) {
        pacBenefits.innerHTML = benefits[rank].map(b => `<p>${b}</p>`).join('');
    }
    
    // Check Zap unlock
    checkZapUnlock();
}


            function updateShopUI() {
                ui.menuCoins.textContent = saveData.coins;
                // UPDATED: Turret cost
                ui.txtTurretCost.textContent = GAME_CONFIG.TURRET.COST;
                
                // Health Upgrade
                const healthCost = GAME_CONFIG.SHOP.HEALTH_BASE * (saveData.upgrades.health + 1);
                ui.lvlHealth.textContent = saveData.upgrades.health + "/5";
                ui.costHealth.textContent = healthCost;
                ui.btnHealth.disabled = (saveData.coins < healthCost) || (saveData.upgrades.health >= 5);
                if(saveData.upgrades.health >= 5) ui.btnHealth.textContent = "MAXED";

                // Magnet Upgrade
                const magnetCost = GAME_CONFIG.SHOP.MAGNET_BASE * (saveData.upgrades.magnet + 1);
                ui.lvlMagnet.textContent = saveData.upgrades.magnet + "/5";
                ui.costMagnet.textContent = magnetCost;
                ui.btnMagnet.disabled = (saveData.coins < magnetCost) || (saveData.upgrades.magnet >= 5);
                if(saveData.upgrades.magnet >= 5) ui.btnMagnet.textContent = "MAXED";

                // Turret
                ui.invTurret.textContent = saveData.inventory.turrets;
                ui.btnTurret.disabled = saveData.coins < GAME_CONFIG.TURRET.COST;

                // Bomb
                ui.invBomb.textContent = saveData.inventory.bombs;
                ui.txtBombCost.textContent = GAME_CONFIG.BOMB.COST;
                ui.btnBomb.disabled = saveData.coins < GAME_CONFIG.BOMB.COST;

// Golden Skin
const skinEquipped = saveData.upgrades.goldSkin && (saveData.upgrades.goldSkinEquipped !== false);

if (saveData.upgrades.goldSkin) {
    if (skinEquipped) {
        document.getElementById('statusSkin').textContent = "Equipped ‚úì";
        document.getElementById('statusSkin').className = "text-[10px] text-green-400 mb-3";
        document.getElementById('buySkin').classList.add('hidden');
        document.getElementById('unequipSkin').classList.remove('hidden');
    } else {
        document.getElementById('statusSkin').textContent = "Owned";
        document.getElementById('statusSkin').className = "text-[10px] text-blue-400 mb-3";
        document.getElementById('buySkin').textContent = "EQUIP";
        document.getElementById('buySkin').disabled = false;
        document.getElementById('buySkin').className = "game-btn px-4 py-3 text-sm w-full bg-green-500 border-green-700 text-white font-bold";
        document.getElementById('buySkin').classList.remove('hidden');
        document.getElementById('unequipSkin').classList.add('hidden');
    }
} else {
    document.getElementById('statusSkin').textContent = "Locked";
    document.getElementById('statusSkin').className = "text-[10px] text-blue-300 mb-3";
    document.getElementById('buySkin').disabled = saveData.coins < GAME_CONFIG.SHOP.SKIN;
    document.getElementById('buySkin').classList.remove('hidden');
    document.getElementById('unequipSkin').classList.add('hidden');
}

// Obsidian Skin
const obsidianEquipped = saveData.upgrades.obsidianSkin && (saveData.upgrades.obsidianSkinEquipped !== false);

if (saveData.upgrades.obsidianSkin) {
    if (obsidianEquipped) {
        document.getElementById('statusObsidianSkin').textContent = "Equipped ‚úì";
        document.getElementById('statusObsidianSkin').className = "text-[10px] text-green-400 mb-3";
        document.getElementById('buyObsidianSkin').classList.add('hidden');
        document.getElementById('unequipObsidianSkin').classList.remove('hidden');
    } else {
        document.getElementById('statusObsidianSkin').textContent = "Owned";
        document.getElementById('statusObsidianSkin').className = "text-[10px] text-blue-400 mb-3";
        document.getElementById('buyObsidianSkin').textContent = "EQUIP";
        document.getElementById('buyObsidianSkin').disabled = false;
        document.getElementById('buyObsidianSkin').className = "game-btn px-4 py-3 text-sm w-full bg-green-500 border-green-700 text-white font-bold";
        document.getElementById('buyObsidianSkin').classList.remove('hidden');
        document.getElementById('unequipObsidianSkin').classList.add('hidden');
    }
} else {
    document.getElementById('statusObsidianSkin').textContent = "Locked";
    document.getElementById('statusObsidianSkin').className = "text-[10px] text-blue-300 mb-3";
    document.getElementById('buyObsidianSkin').disabled = saveData.coins < 1500;
    document.getElementById('buyObsidianSkin').classList.remove('hidden');
    document.getElementById('unequipObsidianSkin').classList.add('hidden');
}


            }

            // --- GAME STATE ---
            let player;
            let keys = {};
            let enemies = [];
            let projectiles = [];
            let effects = []; 
            let drops = []; 
            let turrets = [];
            let bombs = [];
            let floatingTexts = []; 
            let mousePos = { x: 0, y: 0 };
            
            let kills = 0;
            let sessionCoins = 0;
            let sessionTurrets = 0;
            let sessionBombs = 0;
            let frameCount = 0;
            let isGameOver;
            let gameLoopId;
            let currentMap = null;
let mapObjects = [];

            // --- MUSIC SYSTEM ---
let musicEnabled = true;
let backgroundMusic = null;
            
            let wave = 1;
            let waveTimer = GAME_CONFIG.WAVES.DURATION * 60;
            let enemySpawnTimer = 0;
            let difficultyMultiplier = 1;
            let bossActive = false;
            let currentBoss = null;
            let bossWaveCount = 0;

            // --- CLASSES ---

            class Turret {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.w = 20;
                    this.h = 20;
                    this.life = GAME_CONFIG.TURRET.LIFETIME;
                    this.maxLife = GAME_CONFIG.TURRET.LIFETIME;
                    this.range = GAME_CONFIG.TURRET.RANGE;
                    this.cooldown = 0;
                    this.angle = 0;
                }
                update() {
                    this.life--;
                    this.cooldown--;

                    // Find nearest enemy
                    let nearest = null;
                    let minDis = this.range;

                    for(let e of enemies) {
                        const dist = Math.hypot((e.x+e.w/2)-this.x, (e.y+e.h/2)-this.y);
                        if(dist < minDis) {
                            minDis = dist;
                            nearest = e;
                        }
                    }

                    if(nearest) {
                        const dx = (nearest.x + nearest.w/2) - this.x;
                        const dy = (nearest.y + nearest.h/2) - this.y;
                        this.angle = Math.atan2(dy, dx);
                        
                        // Shoot
                        if(this.cooldown <= 0) {
                            projectiles.push(new Projectile(
                                this.x - GAME_CONFIG.PLAYER.BASE_SIZE/2, 
                                this.y - GAME_CONFIG.PLAYER.BASE_SIZE/2, 
                                this.angle, 
                                'turret', 
                                GAME_CONFIG.PROJECTILES.turret.damage
                            )); 
                            this.cooldown = GAME_CONFIG.TURRET.FIRE_RATE; // UPDATED: Slower fire rate
                        }
                    }
                }
                draw() {
                    // Base
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
                    // Gun
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#999';
                    ctx.fillRect(0, -4, 16, 8);
                    ctx.restore();
                    // Bar
                    const width = 24;
                    const pct = this.life / this.maxLife;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - width/2, this.y - 20, width, 4);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(this.x - width/2, this.y - 20, width * pct, 4);
                }
            }

            class FloatingText {
                constructor(x, y, text, color, size = 12) {
                    this.x = x + (Math.random() * 10 - 5);
                    this.y = y;
                    this.text = text;
                    this.color = color;
                    this.size = size;
                    this.life = 40;
                    this.velocity = 1.5;
                    this.alpha = 1;
                }
                update() {
                    this.y -= this.velocity;
                    this.velocity *= 0.9; 
                    this.life--;
                    if (this.life < 15) this.alpha -= 0.06;
                }
                draw() {
                    ctx.globalAlpha = Math.max(0, this.alpha);
                    ctx.font = `${this.size}px "Press Start 2P"`;
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.text, this.x, this.y);
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }

            class DropItem {
constructor(x, y, type, value) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.value = value;
    this.decayTimer = null;
    
    // Visual properties based on type
    if (type === 'goldcoin') {
        this.radius = 10;
        this.color = '#ffd700';
        this.glowColor = '#ffed4e';
    } else if (type === 'health') {
        this.radius = 8;
        this.color = '#ef4444';
        this.glowColor = '#fca5a5';
    } else if (type === 'snowflake') {
        this.radius = 8;
        this.color = '#00d4ff';
        this.glowColor = '#6dd5ed';
    } else if (type === 'coin') {
        this.radius = 6;
        this.color = '#fbbf24';
    } else {
        this.radius = 5;
        this.color = value > 10 ? '#ffd700' : '#00f2fe';
    }
    
    this.magnetized = false;
    this.bounceOffset = Math.random() * Math.PI * 2;
}
                update() {
    // Decay timer for special drops
    if (this.decayTimer !== null) {
        this.decayTimer--;
        if (this.decayTimer <= 0) {
            return true; // Signal for removal
        }
    }
    
    const magnetBonus = player.upgrades.pickupMagnet * 30;
const magnetRange = GAME_CONFIG.PLAYER.BASE_MAGNET + (saveData.upgrades.magnet * GAME_CONFIG.PLAYER.MAGNET_PER_UPGRADE) + magnetBonus;
    const floatY = Math.sin((Date.now() / 200) + this.bounceOffset) * 2;
    const dx = (player.x + player.w/2) - this.x;
    const dy = (player.y + player.h/2) - (this.y + floatY);
    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < magnetRange) this.magnetized = true;
                    
                    if (this.magnetized) {
                        const speed = this.type === 'coin' ? 14 : 12;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                        
                     if (dist < 20) {
    if(this.type === 'coin' || this.type === 'goldcoin') {
        sessionCoins += this.value;
        ui.gameCoins.textContent = sessionCoins;
        if (this.type === 'goldcoin') {
            floatingTexts.push(new FloatingText(this.x, this.y, `+${this.value}G`, '#ffd700', 16));
        }
    } else if (this.type === 'snowflake') {
        if (!saveData.snowflakes) saveData.snowflakes = 0;
        saveData.snowflakes += this.value;
        floatingTexts.push(new FloatingText(this.x, this.y, '+1 ‚ùÑÔ∏è', '#00d4ff', 14));
    } else if (this.type === 'health') {
        player.hp = Math.min(player.maxHp, player.hp + this.value);
        player.updateUI();
        floatingTexts.push(new FloatingText(this.x, this.y, `+${this.value} HP`, '#22c55e', 14));
        effects.push(new Effect(this.x, this.y, 40, 'rgba(34, 197, 94, A)', 'explosion'));
    } else {
        player.gainXp(this.value);
    }
    return true;
}
                    }
                    return false;
                }
                draw() {
    const floatY = this.magnetized ? 0 : Math.sin((Date.now() / 200) + this.bounceOffset) * 2;
    
    // Glow effect for special drops
    if (this.glowColor) {
        ctx.shadowColor = this.glowColor;
        ctx.shadowBlur = 15;
    }
    
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(this.x, this.y + floatY, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Icons for different types
if(this.type === 'coin' || this.type === 'goldcoin') {
    ctx.fillStyle = '#fff';
    ctx.font = this.type === 'goldcoin' ? '10px monospace' : '8px monospace';
    ctx.fillText('$', this.x - (this.type === 'goldcoin' ? 3 : 2), this.y + floatY + 3);
} else if (this.type === 'health') {
    ctx.fillStyle = '#fff';
    ctx.font = '10px monospace';
    ctx.fillText('+', this.x - 3, this.y + floatY + 4);
} else if (this.type === 'snowflake') {
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('‚ùÑ', this.x - 5, this.y + floatY + 4);
}
    
    // Decay warning (flashing)
    if (this.decayTimer !== null && this.decayTimer < 60) {
        if (Math.floor(this.decayTimer / 10) % 2 === 0) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }
}
            }

            class Player {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.w = GAME_CONFIG.PLAYER.BASE_SIZE;
                    this.h = GAME_CONFIG.PLAYER.BASE_SIZE;
                    this.type = type;
                    this.angle = 0;
                    
                    const stats = GAME_CONFIG.CLASSES[type];
                    const bonusHealth = saveData.upgrades.health * GAME_CONFIG.PLAYER.HP_PER_UPGRADE;
                    
                    this.level = 1;
                    this.xp = 0;
                    this.maxXp = 10;
                    this.maxHp = GAME_CONFIG.PLAYER.BASE_HP + (stats.hp_bonus || 0) + bonusHealth;
                    this.hp = this.maxHp;
                    this.speed = GAME_CONFIG.PLAYER.BASE_SPEED * (stats.speed_mult || 1);
                    
                    this.damageMult = stats.damage_mult;
                    this.fireRateMult = stats.fire_rate_mult;
                    this.weaponCooldown = 0;
                    this.slashTimer = 0;

                    this.dashCooldown = 0;
                    this.isDashing = false;
                    this.dashTime = 0;
                    this.canDoubleDash = stats.canDoubleDash || false; // Ninja specific
                    this.doubleDashReady = this.canDoubleDash;         // Ninja specific
                    
                   this.isGold = saveData.upgrades.goldSkin && (saveData.upgrades.goldSkinEquipped !== false);
this.isObsidian = saveData.upgrades.obsidianSkin && (saveData.upgrades.obsidianSkinEquipped !== false);

if (this.isObsidian) {
    this.color = '#3b0764'; // Deep purple-black
} else if (this.isGold) {
    this.color = '#fbbf24';
} else {
    this.color = stats.color;
}

// Temporary run upgrades

this.upgrades = {
    fireRing: 0,
    lightningStorm: 0,
    speedBoostTimer: 0,
    attackSpeed: 0,
    poisonTrail: 0,
    shadowBlades: 0,
    explosiveShots: 0,
    splitShot: 0,
    piercingShots: 0,
    damageBoost: 0,
    regenAura: 0,
    thorns: 0,
    iceBarrier: 0,
    autoHeal: 0,
    maxHealth: 0,
    dodgeChance: 0,
    orbitalDrones: 0,
    extraDashes: 0,
    pickupMagnet: 0,
    xpBoost: 0,
    coinMagnet: 0,
    moveSpeed: 0,
    lifesteal: 0
};
this.shotCounter = 0;
this.healTimer = 0;
this.lightningStormTimer = 0;
this.shadowBladeAngle = 0;
this.regenTimer = 0;

              // Class Specifics
if (type === 'knight') {
    this.swordLength = stats.sword_length;
    this.swordWidth = stats.sword_width;
    this.isSlashing = false;
    // Blade Storm Ability
    this.bladestormCooldown = 0;
    this.bladestormActive = false;
    this.bladestormDuration = 0;
    // SHIELD SYSTEM
    this.shieldMode = false; // false = sword, true = shield
    this.shieldWaveCooldown = 0;
    this.shieldWaveActive = false; // NEW: Track if wave is active
}
// Archer specific
if (type === 'archer') {
    this.ricochetCooldown = 0;
    this.ricochetActive = false;
    this.ricochetShotReady = false; // New flag for single-shot mode
}
// Tempest specific
if (type === 'tempest') {
    this.furyKills = 0;
    this.furyBarMax = stats.furyBarMax;
    this.furyWaveCooldown = 0;
}
// Zap specific
if (type === 'zap') {
    this.overloadCounter = 0; // Tracks shots until Overload Surge (every 3rd)
}
// Unit-7 specific
if (type === 'unit7') {
    this.currentMode = 'laser';
    this.laserCooldown = 0;
    this.microCooldown = 0;
    this.microAmmo = stats.microMaxAmmo;
    this.microMaxAmmo = stats.microMaxAmmo;
}
                }
 

               gainXp(amount) {
    const xpBonus = 1 + (this.upgrades.xpBoost * 0.1);
    this.xp += Math.floor(amount * xpBonus);
    if (this.xp >= this.maxXp) this.levelUp();
    this.updateUI();
}

levelUp() {
    this.level++;
    this.xp = this.xp - this.maxXp;
    this.maxXp = Math.floor(this.maxXp * 1.4); 
    
    // Heal 20% on level up
    this.hp = Math.min(this.hp + (this.maxHp * 0.2), this.maxHp);
    
    // LEVEL 6 CAP: Only show upgrades if level 6 or below
    if (this.level <= 6) {
        showUpgradeChoices();
    } else {
        // Just show level up message, no upgrades
        const levelUpMsg = document.getElementById('levelUpMsg');
        const upgradeText = document.getElementById('upgradeText');
        levelUpMsg.classList.remove('hidden');
        upgradeText.textContent = `Max Level! +HP Restored!`;
        setTimeout(() => levelUpMsg.classList.add('hidden'), 2000);
    }
}
                
               updateUI() {
                    const pct = Math.min(100, (this.xp / this.maxXp) * 100);
                    ui.xpBar.style.width = `${pct}%`;
                    ui.level.textContent = this.level;
                    
ui.hp.textContent = `${Math.floor(this.hp)}/${this.maxHp}`;
                    
                    ui.dashInd.classList.add('hidden');
ui.doubleDashInd.classList.add('hidden');

// NINJA: Show charges available
if (this.canDoubleDash) {
    if (this.dashCharges === undefined) this.dashCharges = 2;
    
    if (this.dashCharges === 2) {
        ui.doubleDashInd.textContent = '‚ö°‚ö° DOUBLE DASH';
        ui.doubleDashInd.classList.remove('hidden');
    } else if (this.dashCharges === 1) {
        ui.dashInd.textContent = '‚ö° DASH READY';
        ui.dashInd.classList.remove('hidden');
    }
    // If 0 charges, show nothing (recharging)
} 
// NORMAL CLASSES: Standard dash indicator
else {
    if (this.dashCooldown <= 0 && !this.isDashing) {
        ui.dashInd.textContent = '‚ö° DASH READY';
        ui.dashInd.classList.remove('hidden');
    } else {
        ui.dashInd.classList.add('hidden');
    }
}
                    // Tempest Fury Bar
    const furyContainer = document.getElementById('furyBarContainer');
    const furyFill = document.getElementById('furyBarFill');
    if (this.type === 'tempest') {
        furyContainer.classList.remove('hidden');
        const furyPct = (this.furyKills / this.furyBarMax) * 100;
        furyFill.style.width = `${furyPct}%`;
    } else {
        furyContainer.classList.add('hidden');
    }
                }

dash() {
    if (this.isDashing) return;
    
    let dashActivated = false;
    let moveX = 0;
    let moveY = 0;
    
    // Calculate movement direction FIRST
    if (keys['ArrowUp'] || keys['KeyW']) moveY = -1;
    if (keys['ArrowDown'] || keys['KeyS']) moveY = 1;
    if (keys['ArrowLeft'] || keys['KeyA']) moveX = -1;
    if (keys['ArrowRight'] || keys['KeyD']) moveX = 1;
    
    // If no input, use mouse direction
    if (moveX === 0 && moveY === 0) {
        moveX = Math.cos(this.angle);
        moveY = Math.sin(this.angle);
    } else {
        const mag = Math.sqrt(moveX*moveX + moveY*moveY);
        moveX /= mag;
        moveY /= mag;
    }

    // NINJA SPECIAL: Two separate dashes with shared cooldown
    if (this.canDoubleDash) {
        if (this.dashCharges === undefined) this.dashCharges = 2; // Initialize if needed
        
        if (this.dashCharges > 0) {
            this.dashCharges--;
            dashActivated = true;
            
            // Start cooldown when last charge is used
            if (this.dashCharges === 0) {
                this.dashCooldown = GAME_CONFIG.PLAYER.DASH.COOLDOWN;
            }
        }
    } 
    // NORMAL CLASSES: Standard single dash with cooldown
    else {
        if (this.dashCooldown <= 0) {
            this.dashCooldown = GAME_CONFIG.PLAYER.DASH.COOLDOWN;
            dashActivated = true;
        }
    }

    if (dashActivated) {
        this.isDashing = true;
        this.dashTime = GAME_CONFIG.PLAYER.DASH.DURATION;
        this.dashVel = { x: moveX * GAME_CONFIG.PLAYER.DASH.SPEED, y: moveY * GAME_CONFIG.PLAYER.DASH.SPEED };
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 20, 'rgba(255,255,255,0.5)', 'explosion')); 
    }
}
                
useBladestorm() {
    if (this.type !== 'knight') return;
    if (!saveData.perks.knightBladestorm) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'PERK LOCKED!', '#ff0000', 12));
        return;
    }
    
    if (this.bladestormCooldown > 0) {
        const secondsLeft = Math.ceil(this.bladestormCooldown / 60);
        floatingTexts.push(new FloatingText(this.x, this.y, `NOT READY! ${secondsLeft}s`, '#ff6600', 12));
        return;
    }
    
    // Activate Bladestorm!
    this.bladestormActive = true;
    this.bladestormDuration = 40; // ‚úÖ NERFED: Was 90, now 45 frames (1.5 seconds)
    this.bladestormCooldown = 720;
    floatingTexts.push(new FloatingText(this.x, this.y, 'BLADE STORM!', '#3b82f6', 18));
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 120, 'rgba(59, 130, 246, A)', 'explosion'));
}

useRicochet() {
    if (this.type !== 'archer') return;
    if (!saveData.perks.archerRicochet) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'PERK LOCKED!', '#ff0000', 12));
        return;
    }
    
    // ‚úÖ FIX: Check cooldown BEFORE showing message
    if (this.ricochetCooldown > 0) {
        const secondsLeft = Math.ceil(this.ricochetCooldown / 60);
        floatingTexts.push(new FloatingText(this.x, this.y, `NOT READY! ${secondsLeft}s`, '#ff6600', 12));
        return; // ‚úÖ STOP HERE - Don't activate ability
    }
    
// Activate Ricochet - Single shot mode!
this.ricochetShotReady = true;
floatingTexts.push(new FloatingText(this.x, this.y, 'RICOCHET READY!', '#16a34a', 18));
effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(22, 163, 74, A)', 'explosion'));
}

useFuryWave() {
    if (this.type !== 'tempest') return;
    
    if (this.furyKills < this.furyBarMax) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'NOT READY!', '#ff6600', 12));
        return;
    }
    
    // Reset fury bar
    this.furyKills = 0;
    this.updateUI();
    
    // ‚úÖ Create EXPANDING wind wave that grows outward
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 600, 'rgba(100, 200, 255, A)', 'expanding_wind_wave'));
    floatingTexts.push(new FloatingText(this.x, this.y, 'FURY WAVE!', '#00d4ff', 18));
}

switchWeaponKnight() {
    if (this.type !== 'knight') return;
    
    // Toggle between sword and shield
    this.shieldMode = !this.shieldMode;
    
    // Visual feedback
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(59, 130, 246, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, this.shieldMode ? 'SHIELD!' : 'SWORD!', '#3b82f6', 12));
}
switchWeapon() {
    if (this.type !== 'unit7') return;
    
    // Toggle mode
    this.currentMode = this.currentMode === 'laser' ? 'micro' : 'laser';
    
    // Visual feedback
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(96, 165, 250, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, this.currentMode.toUpperCase(), '#60a5fa', 12));
}


               update() {
    if (this.dashCooldown > 0) {
        this.dashCooldown--;
        
        // NINJA: Recharge both dashes when cooldown completes
        if (this.canDoubleDash && this.dashCooldown === 0) {
            this.dashCharges = 2;
        }
    }
// Knight Bladestorm System
if (this.bladestormCooldown > 0) this.bladestormCooldown--;
// Speed Boost effect (MORE OBVIOUS)
if (this.speedBoostTimer > 0) {
    this.speedBoostTimer--;
    const baseSpeed = GAME_CONFIG.PLAYER.BASE_SPEED * (GAME_CONFIG.CLASSES[this.type].speed_mult || 1);
    const speedMult = 1 + (this.upgrades.speedBoost * 0.3); // 30% per stack
    this.speed = baseSpeed * speedMult;
    
    // Visual trail effect
    if (frameCount % 3 === 0) {
        effects.push(new Effect(
            this.x + this.w/2,
            this.y + this.h/2,
            15,
            'rgba(251, 191, 36, 0.5)',
            'trail'
        ));
    }
}

// Knight Shield Wave Cooldown
if (this.type === 'knight' && this.shieldWaveCooldown > 0) {
    this.shieldWaveCooldown--;
}
// Unit-7 Weapon System
if (this.type === 'unit7') {
    if (this.laserCooldown > 0) this.laserCooldown--;
    // Micro mode has NO cooldown, just ammo tracking
    // No microCooldown decrement needed
    // Regenerate micro ammo when not on cooldown
    if (this.microCooldown <= 0 && this.microAmmo < this.microMaxAmmo) {
        this.microAmmo = this.microMaxAmmo;
    }
}
if (this.bladestormActive) {
    this.bladestormDuration--;
    if (this.bladestormDuration <= 0) this.bladestormActive = false;
    
    if (frameCount % 5 === 0) {
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < 120) {
                hitEnemy(e, 10);
            }
        });
    }
}

// Archer Ricochet System
if (this.ricochetCooldown > 0) this.ricochetCooldown--;


// ‚ú® MAJESTIC PAC TRAIL EFFECT
if (frameCount % 3 === 0) {
    const trailColor = saveData.pac.trailColor;
    
    const r = parseInt(trailColor.slice(1, 3), 16);
    const g = parseInt(trailColor.slice(3, 5), 16);
    const b = parseInt(trailColor.slice(5, 7), 16);
    
    for (let i = 0; i < 3; i++) {
        const offsetX = (Math.random() - 0.5) * 15;
        const offsetY = (Math.random() - 0.5) * 15;
        const alpha = 0.4 - (i * 0.1);
        const radius = 18 - (i * 4);
        
        effects.push(new Effect(
            this.x + this.w/2 + offsetX,
            this.y + this.h/2 + offsetY,
            radius,
            `rgba(${r}, ${g}, ${b}, ${alpha})`,
            'trail'
        ));
    }
    
    if (saveData.pac.rank !== 'rookie' && Math.random() < 0.3) {
        effects.push(new Effect(
            this.x + this.w/2 + (Math.random() - 0.5) * 20,
            this.y + this.h/2 + (Math.random() - 0.5) * 20,
            8,
            'rgba(255, 255, 255, 0.6)',
            'trail'
        ));
    }

    
    // =====================================================
// =====================================================
// =====================================================
    // APPLY TEMPORARY UPGRADES
    // =====================================================

    // Fire Ring - Burns nearby enemies
    if (this.upgrades.fireRing > 0 && frameCount % 8 === 0) {
        const ringRadius = 70;
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < ringRadius) {
                hitEnemy(e, 1.2 * this.upgrades.fireRing);
            }
        });
    }

    // Lightning Storm - Call down lightning bolts
    if (this.upgrades.lightningStorm > 0) {
        this.lightningStormTimer++;
        const cooldown = Math.max(90, 270 - (this.upgrades.lightningStorm * 45));
        
        if (this.lightningStormTimer >= cooldown) {
            this.lightningStormTimer = 0;
            
            const totalStrikes = this.upgrades.lightningStorm;
            
            for (let i = 0; i < totalStrikes && enemies.length > 0; i++) {
                const target = enemies[Math.floor(Math.random() * enemies.length)];
                
                // Create lightning bolt from top of screen
                const lightningBolt = {
                    x: target.x + target.w/2,
                    y: target.y + target.h/2,
                    life: 15,
                    targetEnemy: target
                };
                
                // Draw lightning bolt in effects array
                effects.push({
                    x: lightningBolt.x,
                    y: 0,
                    targetX: lightningBolt.x,
                    targetY: lightningBolt.y,
                    life: 15,
                    lifeMax: 15,
                    type: 'lightning_bolt',
                    update: function() {
                        this.life--;
                    },
                    draw: function() {
                        if (this.life <= 0) return;
                        
                        ctx.save();
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 4;
                        ctx.shadowColor = '#60a5fa';
                        ctx.shadowBlur = 20;
                        
                        // Jagged lightning path
                        ctx.beginPath();
                        ctx.moveTo(this.targetX, 0);
                        
                        const segments = 8;
                        const segmentHeight = this.targetY / segments;
                        let currentX = this.targetX;
                        
                        for (let i = 1; i <= segments; i++) {
                            const offsetX = (Math.random() - 0.5) * 30;
                            currentX += offsetX;
                            ctx.lineTo(currentX, i * segmentHeight);
                        }
                        
                        ctx.stroke();
                        
                        // Inner white core
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                
                // Explosion effect at impact
                effects.push(new Effect(target.x + target.w/2, target.y + target.h/2, 50, 'rgba(96, 165, 250, 0.9)', 'explosion'));
                
                // Deal damage
                hitEnemy(target, 6);
                floatingTexts.push(new FloatingText(target.x, target.y, '‚ö°', '#60a5fa', 18));
            }
        }
    }

    // Auto-Heal
    if (this.upgrades.autoHeal > 0) {
        this.healTimer++;
        if (this.healTimer >= 480) {
            const healAmount = 2 * this.upgrades.autoHeal;
            this.hp = Math.min(this.hp + healAmount, this.maxHp);
            this.healTimer = 0;
            floatingTexts.push(new FloatingText(this.x, this.y, `+${healAmount} HP`, '#22c55e', 12));
        }
    }

// Regeneration Aura
if (this.upgrades.regenAura > 0) {
    this.regenTimer++;
    // Heal every 180 frames (3 seconds at 60fps) - NERFED
    if (this.regenTimer >= 180) { // NERFED: Was 120, now 180
        const healAmount = 2 * this.upgrades.regenAura; // NERFED: Was 3, now 2
        const actualHeal = Math.min(healAmount, this.maxHp - this.hp);
        
        if (actualHeal > 0) {
            this.hp = Math.min(this.hp + healAmount, this.maxHp);
            floatingTexts.push(new FloatingText(
                this.x, 
                this.y, 
                `+${actualHeal} HP`, 
                '#22c55e', 
                14
            ));
            // Green healing pulse effect
            effects.push(new Effect(
                this.x + this.w/2, 
                this.y + this.h/2, 
                30, 
                'rgba(34, 197, 94, 0.5)', 
                'explosion'
            ));
        }
        
        this.regenTimer = 0;
        this.updateUI();
    }
}

// Ice Barrier - Freeze enemies on contact (NO DAMAGE, JUST SLOW)
if (this.upgrades.iceBarrier > 0) {
    const iceRadius = 70 + (this.upgrades.iceBarrier * 15);
    const slowPercent = 0.6 - (this.upgrades.iceBarrier * 0.05); // NERFED: Was 0.4, now 0.6 (less slow)
        
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < iceRadius) {
                if (!e.iceSlowed) {
                    e.iceSlowed = true;
                    e.originalSpeed = e.speed;
                }
                e.speed = e.originalSpeed * Math.max(0.2, slowPercent);
            } else if (e.iceSlowed) {
                e.speed = e.originalSpeed;
                e.iceSlowed = false;
            }
        });
    }

    // Lifesteal tracking
    if (this.upgrades.lifesteal > 0) {
        // Healing happens in hitEnemy function
    }
}
                    
                    if (this.isDashing) {
                        this.x += this.dashVel.x;
                        this.y += this.dashVel.y;
                        this.dashTime--;
                        this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));
                        this.y = Math.max(0, Math.min(canvas.height - this.h, this.y));
                        if (this.dashTime <= 0) this.isDashing = false;
                        this.draw();
                        return; 
                    }

                    let speedMod = 1;
                    for (const effect of effects) {
                        if (effect.type === 'ice_field') {
                            const dist = Math.hypot((this.x+this.w/2)-effect.x, (this.y+this.h/2)-effect.y);
                            if (dist < effect.radius) speedMod = 0.6;
                        }
                    }

                   // Slow Field upgrade
if (player && player.upgrades.slowField > 0) {
    const dist = Math.hypot((this.x + this.w/2) - (player.x + player.w/2),
                           (this.y + this.h/2) - (player.y + player.h/2));
    if (dist < 120) {
        speed *= Math.max(0.5, 1 - (player.upgrades.slowField * 0.2));
    }
}

                    
                   // Calculate movement direction
let moveX = 0;
let moveY = 0;
if ((keys['ArrowUp'] || keys['KeyW']) && this.y > 0) moveY = -1;
if ((keys['ArrowDown'] || keys['KeyS']) && this.y < canvas.height - this.h) moveY = 1;
if ((keys['ArrowLeft'] || keys['KeyA']) && this.x > 0) moveX = -1;
if ((keys['ArrowRight'] || keys['KeyD']) && this.x < canvas.width - this.w) moveX = 1;

// Normalize diagonal movement (prevents 1.414x speed)
if (moveX !== 0 && moveY !== 0) {
    const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
    moveX /= magnitude;
    moveY /= magnitude;
}

// Apply movement WITH WALL COLLISION
let finalSpeed = this.speed * speedMod;

// Knight shield penalty
if (this.type === 'knight' && this.shieldMode) {
    finalSpeed *= 0.7; // 30% slower with shield
}

const moveSpeed = finalSpeed;
const newX = this.x + moveX * moveSpeed;
const newY = this.y + moveY * moveSpeed;

this.x = newX;
this.y = newY;

// Normal boundary collision
this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));
this.y = Math.max(0, Math.min(canvas.height - this.h, this.y));
                    if (keys['Space']) this.dash();
                    if (keys['Space']) this.dash();

if (keys['KeyV']) {
    if (this.type === 'knight') {
        this.useBladestorm();
    } else if (this.type === 'archer') {
        this.useRicochet();
    }
    keys['KeyV'] = false;
}

// Tempest Fury Wave (separate key)
if (keys['KeyC'] && this.type === 'tempest') {
    this.useFuryWave();
    keys['KeyC'] = false;
}
// Unit-7 Weapon Switch
if (keys['KeyQ'] && this.type === 'unit7') {
    this.switchWeapon();
    keys['KeyQ'] = false;
}
// Knight Shield Switch
if (keys['KeyQ'] && this.type === 'knight') {
    this.switchWeaponKnight();
    keys['KeyQ'] = false;
}


                    if (keys['KeyT']) {
                        if (sessionTurrets > 0) {
                            sessionTurrets--;
                            ui.hudTurretCount.textContent = sessionTurrets;
                            turrets.push(new Turret(this.x + this.w/2, this.y + this.h/2));
                            keys['KeyT'] = false; 
                        }
                    }
                 if (keys['KeyB']) {
    if (sessionBombs > 0) {
        sessionBombs--;
        ui.hudBombCount.textContent = sessionBombs;
        
        const bombX = this.x + this.w/2;
        const bombY = this.y + this.h/2;
        
        // Create explosion effect
        effects.push(new Effect(bombX, bombY, GAME_CONFIG.BOMB.RADIUS, 'rgba(255, 100, 0, A)', 'explosion'));
        
        // Hit all enemies in radius
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot((e.x + e.w/2) - bombX, (e.y + e.h/2) - bombY);
            if (dist < GAME_CONFIG.BOMB.RADIUS) {
                hitEnemy(e, GAME_CONFIG.BOMB.DAMAGE);
            }
        }
        
        floatingTexts.push(new FloatingText(bombX, bombY, 'üí£ BOOM!', '#ff6600', 20));
        keys['KeyB'] = false;
    } else if (sessionBombs <= 0 && keys['KeyB']) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'No Bombs!', '#ff0000', 12));
        keys['KeyB'] = false;
    }
}

                    const dx = mousePos.x - (this.x + this.w / 2);
const dy = mousePos.y - (this.y + this.h / 2);
this.angle = Math.atan2(dy, dx);
                    
                    this.weaponCooldown--;
                    if (this.isSlashing) {
                        this.slashTimer--;
                        if (this.slashTimer <= 0) this.isSlashing = false;
                    }
                    
                    this.draw();
                }
                
                draw() {
                    if (this.isDashing) {
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(this.x - this.dashVel.x, this.y - this.dashVel.y, this.w, this.h);
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.fillRect(this.x + 4, this.y + 8, this.w, this.h - 4);
                    ctx.fillStyle = this.color;
ctx.fillRect(this.x, this.y, this.w, this.h);

if (this.isObsidian) {
    // Obsidian Knight - Epic crystalline effect
    ctx.save();
    
    // Dark crystal shards
    ctx.strokeStyle = '#7c3aed';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, this.y, this.w, this.h);
    
    // Inner crystalline pattern
    ctx.strokeStyle = '#a78bfa';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.w, this.y + this.h);
    ctx.moveTo(this.x + this.w, this.y);
    ctx.lineTo(this.x, this.y + this.h);
    ctx.stroke();
    
    // Glowing purple runes (animated)
    const runeOpacity = 0.6 + Math.sin(frameCount * 0.1) * 0.4;
    ctx.fillStyle = `rgba(167, 139, 250, ${runeOpacity})`;
    
    // Rune symbols (simple geometric shapes)
    ctx.fillRect(this.x + 2, this.y + 2, 4, 4);
    ctx.fillRect(this.x + this.w - 6, this.y + 2, 4, 4);
    ctx.fillRect(this.x + 2, this.y + this.h - 6, 4, 4);
    ctx.fillRect(this.x + this.w - 6, this.y + this.h - 6, 4, 4);
    
    // Center glowing core
    ctx.shadowColor = '#a78bfa';
    ctx.shadowBlur = 10;
    ctx.fillStyle = `rgba(196, 181, 253, ${runeOpacity})`;
    ctx.fillRect(this.x + this.w/2 - 3, this.y + this.h/2 - 3, 6, 6);
    ctx.shadowBlur = 0;
    
    // Particle trail effect (only if moving)
    if (frameCount % 3 === 0 && (Math.abs(this.x - (this.lastX || this.x)) > 1 || Math.abs(this.y - (this.lastY || this.y)) > 1)) {
        effects.push(new Effect(
            this.x + this.w/2 + (Math.random() - 0.5) * 10,
            this.y + this.h/2 + (Math.random() - 0.5) * 10,
            8,
            'rgba(167, 139, 250, 0.6)',
            'trail'
        ));
    }
    
    this.lastX = this.x;
    this.lastY = this.y;
    
    ctx.restore();
} else if (this.isGold) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, this.y, this.w, this.h);
}
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x + 4, this.y + 6, 8, 8);
                    ctx.fillRect(this.x + 16, this.y + 6, 8, 8);
                    ctx.fillStyle = 'black';
                    const xOffset = Math.cos(this.angle) * 2;
                    const yOffset = Math.sin(this.angle) * 2;
                    ctx.fillRect(this.x + 6 + xOffset, this.y + 8 + yOffset, 4, 4);
                    ctx.fillRect(this.x + 18 + xOffset, this.y + 8 + yOffset, 4, 4);

                    
                   if (this.type === 'knight') {
    if (this.shieldMode) {
        this.drawKnightShield();
    } else {
        this.drawKnightSword();
    }
    if (this.bladestormActive) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 20;
        const spinAngle = (frameCount * 0.3) % (Math.PI * 2);
        for (let i = 0; i < 4; i++) {
            const angle = spinAngle + (i * Math.PI / 2);
            ctx.beginPath();
            ctx.arc(0, 0, 100, angle, angle + Math.PI / 3);
            ctx.stroke();
        }
        ctx.restore();

        // =====================================================
// DRAW UPGRADE VISUAL EFFECTS
// =====================================================

// Shadow Blades
if (this.upgrades.shadowBlades > 0) {
    ctx.save();
    const bladeRadius = 55;
    for (let i = 0; i < this.upgrades.shadowBlades; i++) {
        const angle = this.shadowBladeAngle + (i * Math.PI * 2 / this.upgrades.shadowBlades);
        const bladeX = this.x + this.w/2 + Math.cos(angle) * bladeRadius;
        const bladeY = this.y + this.h/2 + Math.sin(angle) * bladeRadius;
        
        ctx.translate(bladeX, bladeY);
        ctx.rotate(angle + Math.PI/2);
        
        // Blade glow
        ctx.shadowColor = '#9333ea';
        ctx.shadowBlur = 15;
        
        // Blade shape
        ctx.fillStyle = '#6b21a8';
        ctx.fillRect(-14, -4, 28, 8);
        ctx.fillStyle = '#9333ea';
        ctx.fillRect(-10, -2, 20, 4);
        
        // Blade tip
        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.lineTo(18, -4);
        ctx.lineTo(18, 4);
        ctx.closePath();
        ctx.fillStyle = '#a855f7';
        ctx.fill();
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Combat Drones - FIXED RENDERING
if (this.upgrades.orbitalDrones > 0 && this.droneSystem) {
    ctx.save();
    const droneRadius = 80;
    const droneCount = this.upgrades.orbitalDrones;
    
    for (let i = 0; i < droneCount; i++) {
        if (!this.droneSystem.angles[i]) continue;
        
        const angle = this.droneSystem.angles[i];
        const droneX = this.x + this.w/2 + Math.cos(angle) * droneRadius;
        const droneY = this.y + this.h/2 + Math.sin(angle) * droneRadius;
        
        // Drone body - metallic shell
        ctx.fillStyle = '#1e293b';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Drone border ring
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 12, 0, Math.PI * 2);
        ctx.stroke();
        
        // Glowing core
        ctx.fillStyle = '#60a5fa';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner bright core
        ctx.fillStyle = '#93c5fd';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Spinning propeller blades
        const spinAngle = (frameCount * 0.2) + (i * Math.PI / droneCount);
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#94a3b8';
        for (let b = 0; b < 4; b++) {
            const bladeAngle = spinAngle + (b * Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(droneX, droneY);
            ctx.lineTo(
                droneX + Math.cos(bladeAngle) * 16,
                droneY + Math.sin(bladeAngle) * 16
            );
            ctx.stroke();
        }
        
        // Targeting laser when about to fire
        if (this.droneSystem.cooldowns[i] <= 5 && this.droneSystem.cooldowns[i] > 0 && enemies.length > 0) {
            let nearest = null;
            let minDist = 250;
            
            for (const e of enemies) {
                const dist = Math.hypot((e.x + e.w/2) - droneX, (e.y + e.h/2) - droneY);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = e;
                }
            }
            
            if (nearest) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(droneX, droneY);
                ctx.lineTo(nearest.x + nearest.w/2, nearest.y + nearest.h/2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Fire Ring indicator with particles
if (this.upgrades.fireRing > 0) {
    ctx.save();
    const fireOpacity = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
    ctx.strokeStyle = `rgba(239, 68, 68, ${fireOpacity})`;
    ctx.lineWidth = 4;
    ctx.shadowColor = '#ff6400';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 70, 0, Math.PI * 2);
    ctx.stroke();
    
    // Fire particles orbiting
    const particleCount = 8 + (this.upgrades.fireRing * 2);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.08 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const particleX = this.x + this.w/2 + Math.cos(angle) * 70;
        const particleY = this.y + this.h/2 + Math.sin(angle) * 70;
        const particleSize = 4 + Math.sin(frameCount * 0.1 + i) * 2;
        
        ctx.fillStyle = `rgba(251, 146, 60, ${fireOpacity + 0.4})`;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Ice Barrier visual
if (this.upgrades.iceBarrier > 0) {
    ctx.save();
    ctx.strokeStyle = `rgba(100, 200, 255, ${0.4 + Math.sin(frameCount * 0.08) * 0.2})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00d4ff';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 45, 0, Math.PI * 2);
    ctx.stroke();
    
    // Ice crystals
    if (frameCount % 15 === 0) {
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) + (frameCount * 0.02);
            const crystalX = this.x + this.w/2 + Math.cos(angle) * 45;
            const crystalY = this.y + this.h/2 + Math.sin(angle) * 45;
            ctx.fillStyle = 'rgba(200, 240, 255, 0.7)';
            ctx.fillRect(crystalX - 3, crystalY - 3, 6, 6);
        }
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Combat Drones - Simple and Visible
if (this.upgrades.orbitalDrones > 0 && this.droneAngles) {
    ctx.save();
    const droneRadius = 80;
    const droneCount = this.upgrades.orbitalDrones;
    
    for (let i = 0; i < droneCount; i++) {
        const angle = this.droneAngles[i] || 0;
        const droneX = this.x + this.w/2 + Math.cos(angle) * droneRadius;
        const droneY = this.y + this.h/2 + Math.sin(angle) * droneRadius;
        
        // Drone body - simple blue circle
        ctx.fillStyle = '#3b82f6';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // White core
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Simple rotating line (propeller indicator)
        const spinAngle = (frameCount * 0.2) + (i * Math.PI / droneCount);
        ctx.strokeStyle = '#60a5fa';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(droneX, droneY);
        ctx.lineTo(
            droneX + Math.cos(spinAngle) * 12,
            droneY + Math.sin(spinAngle) * 12
        );
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Ice Barrier - ULTRA VISIBLE with blue glow
if (this.upgrades.iceBarrier > 0) {
    ctx.save();
    const iceRadius = 70 + (this.upgrades.iceBarrier * 15);
    const iceOpacity = 0.6 + Math.sin(frameCount * 0.08) * 0.3;
    
    // Massive glowing aura
    const gradient = ctx.createRadialGradient(
        this.x + this.w/2, this.y + this.h/2, 0,
        this.x + this.w/2, this.y + this.h/2, iceRadius
    );
    gradient.addColorStop(0, 'rgba(56, 189, 248, 0.4)');
    gradient.addColorStop(0.5, `rgba(56, 189, 248, ${iceOpacity * 0.5})`);
    gradient.addColorStop(1, 'rgba(56, 189, 248, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // THICK main ice ring
    ctx.strokeStyle = `rgba(56, 189, 248, ${iceOpacity})`;
    ctx.lineWidth = 8;
    ctx.shadowColor = '#38bdf8';
    ctx.shadowBlur = 30;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Secondary bright ring
    ctx.strokeStyle = `rgba(224, 242, 254, ${iceOpacity})`;
    ctx.lineWidth = 4;
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius - 10, 0, Math.PI * 2);
    ctx.stroke();
    
    // Massive amount of frost particles
    const particleCount = 24 + (this.upgrades.iceBarrier * 8);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.05 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const particleX = this.x + this.w/2 + Math.cos(angle) * iceRadius;
        const particleY = this.y + this.h/2 + Math.sin(angle) * iceRadius;
        const particleSize = 5 + Math.sin(frameCount * 0.1 + i) * 3;
        
        // Bright glowing particle
        ctx.fillStyle = `rgba(255, 255, 255, ${iceOpacity})`;
        ctx.shadowColor = '#bae6fd';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Regeneration Aura - Green healing particles
if (this.upgrades.regenAura > 0) {
    ctx.save();
    
    // Pulsing green aura
    const regenAlpha = 0.2 + Math.sin(frameCount * 0.08) * 0.1;
    const auraRadius = 35 + (this.upgrades.regenAura * 3);
    
    // Outer glow
    const gradient = ctx.createRadialGradient(
        this.x + this.w/2, this.y + this.h/2, 0,
        this.x + this.w/2, this.y + this.h/2, auraRadius
    );
    gradient.addColorStop(0, `rgba(34, 197, 94, ${regenAlpha * 0.6})`);
    gradient.addColorStop(0.5, `rgba(34, 197, 94, ${regenAlpha * 0.3})`);
    gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Floating healing particles
    const particleCount = 6 + (this.upgrades.regenAura * 2);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.03 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const floatOffset = Math.sin(frameCount * 0.05 + i) * 5;
        const particleX = this.x + this.w/2 + Math.cos(angle) * (auraRadius - 10);
        const particleY = this.y + this.h/2 + Math.sin(angle) * (auraRadius - 10) + floatOffset;
        
        ctx.fillStyle = `rgba(134, 239, 172, ${regenAlpha + 0.4})`;
        ctx.shadowColor = '#22c55e';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
    }
}

                    if (this.type === 'archer') this.drawBow();
                    if (this.type === 'mage') this.drawStaff();
                    if (this.type === 'ninja') this.drawNinjaHeadband();
                    if (this.type === 'tempest') this.drawTempestSwirl();
                    if (this.type === 'zap') this.drawZapLightning();
                    if (this.type === 'unit7') this.drawUnit7Weapons();
// Draw Crown if equipped
if (saveData.cosmetics.crown && saveData.cosmetics.crown.equipped) {
    ctx.save();
    ctx.font = '20px monospace';
    ctx.textAlign = 'center';
    const bobbing = Math.sin(Date.now() / 200) * 2;
    ctx.fillText('üëë', this.x + this.w/2, this.y - 10 + bobbing);
    ctx.restore();
}

// Draw Christmas Cosmetics
if (saveData.cosmetics) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const centerY = this.y + this.h/2;
    
    // Santa Hat - Realistic fabric rendering
    if (saveData.cosmetics.santaHat?.equipped) {
        const hatY = this.y - 18;
        // Red hat body
        ctx.fillStyle = '#c91818';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 8);
        ctx.lineTo(centerX - 16, hatY + 10);
        ctx.lineTo(centerX + 16, hatY + 10);
        ctx.closePath();
        ctx.fill();
        
        // Darker red for depth
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 8);
        ctx.lineTo(centerX + 16, hatY + 10);
        ctx.lineTo(centerX + 12, hatY + 10);
        ctx.closePath();
        ctx.fill();
        
        // White fur trim
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(centerX - 16, hatY + 10, 32, 4);
        
        // White pom-pom with glow
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(centerX + 12, hatY - 4, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    
    // Elf Hat - Green with jingle bell
    if (saveData.cosmetics.elfHat?.equipped) {
        const hatY = this.y - 16;
        // Green hat
        ctx.fillStyle = '#228b22';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 12);
        ctx.lineTo(centerX - 14, hatY + 8);
        ctx.lineTo(centerX + 14, hatY + 8);
        ctx.closePath();
        ctx.fill();
        
        // Dark green shading
        ctx.fillStyle = '#006400';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 12);
        ctx.lineTo(centerX + 14, hatY + 8);
        ctx.lineTo(centerX + 10, hatY + 8);
        ctx.closePath();
        ctx.fill();
        
        // Yellow trim
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(centerX - 14, hatY + 8, 28, 3);
        
        // Red jingle bell at tip with shine
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(centerX + 10, hatY - 8, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffaaaa';
        ctx.beginPath();
        ctx.arc(centerX + 11, hatY - 9, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Reindeer Antlers - Brown branching
    if (saveData.cosmetics.antlers?.equipped) {
        const antlerY = this.y - 10;
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        // Left antler
        ctx.beginPath();
        ctx.moveTo(centerX - 10, antlerY);
        ctx.lineTo(centerX - 14, antlerY - 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX - 13, antlerY - 6);
        ctx.lineTo(centerX - 16, antlerY - 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX - 13, antlerY - 9);
        ctx.lineTo(centerX - 18, antlerY - 10);
        ctx.stroke();
        
        // Right antler
        ctx.beginPath();
        ctx.moveTo(centerX + 10, antlerY);
        ctx.lineTo(centerX + 14, antlerY - 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX + 13, antlerY - 6);
        ctx.lineTo(centerX + 16, antlerY - 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX + 13, antlerY - 9);
        ctx.lineTo(centerX + 18, antlerY - 10);
        ctx.stroke();
        
        ctx.lineWidth = 1;
    }
    
    // Carrot Nose - 3D rendered carrot
    if (saveData.cosmetics.carrotNose?.equipped) {
        const noseX = centerX + 14;
        const noseY = centerY;
        
        // Orange carrot body gradient
        const gradient = ctx.createLinearGradient(noseX, noseY - 4, noseX + 10, noseY);
        gradient.addColorStop(0, '#ff8c00');
        gradient.addColorStop(1, '#ff4500');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(noseX, noseY - 4);
        ctx.lineTo(noseX + 10, noseY);
        ctx.lineTo(noseX, noseY + 4);
        ctx.closePath();
        ctx.fill();
        
        // Dark orange lines for texture
        ctx.strokeStyle = '#cc6600';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(noseX + 2, noseY - 2);
        ctx.lineTo(noseX + 2, noseY + 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(noseX + 5, noseY - 1);
        ctx.lineTo(noseX + 5, noseY + 1);
        ctx.stroke();
        
        // Highlight
        ctx.fillStyle = '#ffa500';
        ctx.fillRect(noseX + 1, noseY - 2, 2, 1);
    }
    
    ctx.restore();

}

// =====================================================
// DRAW UPGRADE EFFECTS
// =====================================================

// Orbiting Blades
if (this.upgrades.orbitingBlades > 0) {
    ctx.save();
    const bladeRadius = 50;
    for (let i = 0; i < this.upgrades.orbitingBlades; i++) {
        const angle = this.orbitAngle + (i * Math.PI * 2 / this.upgrades.orbitingBlades);
        const bladeX = this.x + this.w/2 + Math.cos(angle) * bladeRadius;
        const bladeY = this.y + this.h/2 + Math.sin(angle) * bladeRadius;
        
        ctx.translate(bladeX, bladeY);
        ctx.rotate(angle);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(-12, -3, 24, 6);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(-8, -1, 16, 2);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    ctx.restore();
}

// Shield Bubbles
if (this.upgrades.shieldBubbles > 0) {
    ctx.save();
    const shieldRadius = 40;
    for (let i = 0; i < this.upgrades.shieldBubbles; i++) {
        const angle = this.shieldAngle + (i * Math.PI * 2 / this.upgrades.shieldBubbles);
        const shieldX = this.x + this.w/2 + Math.cos(angle) * shieldRadius;
        const shieldY = this.y + this.h/2 + Math.sin(angle) * shieldRadius;
        
        ctx.fillStyle = '#60a5fa';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(shieldX, shieldY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
    ctx.restore();
}

// Fire Ring indicator with particles
if (this.upgrades.fireRing > 0) {
    ctx.save();
    const fireOpacity = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
    ctx.strokeStyle = `rgba(255, 100, 0, ${fireOpacity})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#ff6400';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 60, 0, Math.PI * 2);
    ctx.stroke();
    
    // Fire particles
    if (frameCount % 5 === 0) {
        for (let i = 0; i < this.upgrades.fireRing; i++) {
            const angle = (frameCount * 0.05 + i * Math.PI * 2 / this.upgrades.fireRing) % (Math.PI * 2);
            const particleX = this.x + this.w/2 + Math.cos(angle) * 60;
            const particleY = this.y + this.h/2 + Math.sin(angle) * 60;
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${fireOpacity + 0.3})`;
            ctx.beginPath();
            ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.restore();
}

// Slow Field visual indicator
if (this.upgrades.slowField > 0) {
    ctx.save();
    ctx.strokeStyle = `rgba(0, 150, 255, ${0.2 + Math.sin(frameCount * 0.08) * 0.15})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 120, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
}
                }
                
                drawBow() {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.angle);
                    ctx.strokeStyle = '#854d0e';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(12, 0, 16, -Math.PI/2, Math.PI/2);
                    ctx.stroke();
                    ctx.fillStyle = '#fff'; 
                    ctx.fillRect(12, -16, 2, 32);
                    ctx.restore();
                }

                drawStaff() {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#854d0e';
                    ctx.fillRect(12, -3, 24, 6);
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(36, 0, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                drawKnightSword() {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(0, -4, 12, 8);
                    ctx.fillStyle = this.isGold ? '#fbbf24' : '#d4af37';
                    ctx.fillRect(12, -10, 6, 20);
                    ctx.fillStyle = '#e2e8f0';
                    ctx.fillRect(18, -this.swordWidth/2, this.swordLength, this.swordWidth);
                    if (this.isSlashing) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, this.swordLength + 20, -Math.PI/3, Math.PI/3);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                drawKnightShield() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Shield body (blue metallic)
    ctx.fillStyle = '#3b82f6';
    ctx.strokeStyle = '#1e40af';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(20, 0, 20, -Math.PI/2, Math.PI/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Shield rim (darker blue)
    ctx.strokeStyle = '#1e3a8a';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Shield emblem (cross)
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(20, -10);
    ctx.lineTo(20, 10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(12, 0);
    ctx.lineTo(28, 0);
    ctx.stroke();
    
    ctx.restore();
}

                drawNinjaHeadband() {
                    ctx.fillStyle = '#dc2626'; // Red
                    ctx.fillRect(this.x, this.y + 5, this.w, 4);
                }
                drawTempestSwirl() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.w/2);
    const swirl = (frameCount * 0.1) % (Math.PI * 2);
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, 15 + (i * 3), swirl + (i * 0.5), swirl + Math.PI + (i * 0.5));
        ctx.stroke();
    }
    ctx.restore();
}

drawZapLightning() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    
    // Electric sparks around body (intensity based on charge)
    const chargePercent = (this.chargeCounter || 0) / 100;
    const sparkCount = 4 + Math.floor(chargePercent * 4);
    const time = frameCount * 0.2;
    
    for (let i = 0; i < sparkCount; i++) {
        const angle = (time + (i * Math.PI * 2 / sparkCount)) % (Math.PI * 2);
        const dist = 12 + Math.sin(time * 2 + i) * 3 + (chargePercent * 5);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        
        const sparkColor = chargePercent >= 1 ? '#fff' : (Math.random() > 0.5 ? '#60a5fa' : '#fbbf24');
        ctx.fillStyle = sparkColor;
        ctx.beginPath();
        ctx.arc(x, y, 2 + (chargePercent * 2), 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Charge indicator ring
    if (chargePercent > 0) {
        const ringColor = chargePercent >= 1 ? '#fff' : '#fbbf24';
        ctx.shadowColor = ringColor;
        ctx.shadowBlur = chargePercent >= 1 ? 30 : 20;
        ctx.strokeStyle = ringColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 18, 0, Math.PI * 2 * chargePercent);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Pulse when fully charged
        if (chargePercent >= 1 && Math.floor(time) % 2 === 0) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    ctx.restore();
    
    // Charge bar above player
    if (chargePercent > 0) {
        const barWidth = 40;
        const barX = this.x + this.w/2 - barWidth/2;
        const barY = this.y - 8;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(barX - 1, barY - 1, barWidth + 2, 5);
        
        const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
        gradient.addColorStop(0, '#fbbf24');
        gradient.addColorStop(1, chargePercent >= 1 ? '#fff' : '#60a5fa');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth * chargePercent, 3);
        
        ctx.strokeStyle = chargePercent >= 1 ? '#fff' : '#fbbf24';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, 3);
    }
}

drawUnit7Weapons() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Glowing core
    ctx.shadowColor = '#60a5fa';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#3b82f6';
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Draw active weapon
    if (this.currentMode === 'laser') {
        // Laser Cannon (large)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(8, -6, 20, 12);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(28, -4, 8, 8);
        
        // Charge indicator
        if (this.laserCooldown > 0) {
            const chargePercent = 1 - (this.laserCooldown / 180);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(28, -4, 8 * chargePercent, 8);
        }
    } else {
        // Micro Blaster (small multi-barrel)
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(8, -4, 16, 8);
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(24, -3 + (i * 3), 4, 2);
        }
    }
    
    ctx.restore();
    
    // Mode indicator above player
    ctx.fillStyle = this.currentMode === 'laser' ? '#3b82f6' : '#fbbf24';
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(this.currentMode === 'laser' ? 'LASER' : 'MICRO', this.x + this.w/2, this.y - 10);
    ctx.textAlign = 'left';
    
    // Ammo bar for micro mode
    if (this.currentMode === 'micro') {
        const barWidth = 30;
        const barX = this.x + this.w/2 - barWidth/2;
        const barY = this.y - 4;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(barX - 1, barY - 1, barWidth + 2, 4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(barX, barY, barWidth * (this.microAmmo / this.microMaxAmmo), 2);
    }
}
                
                shoot() {
                    if (this.weaponCooldown > 0) return;
                    
                    let weaponType = null;
                    let cooldownFrames = 0;

                    if (this.type === 'mage') {
                        weaponType = 'fireball';
                        cooldownFrames = 60;
}else if (this.type === 'archer') {
    weaponType = 'arrow';
    cooldownFrames = 20;
    
    // Check if ricochet is active - shoot 6 arrows instead of 3
    const arrowCount = this.ricochetShotReady ? 6 : 3;
    const damage = GAME_CONFIG.PROJECTILES.arrow.damage * this.damageMult * 0.45;
    const spreadAngle = Math.PI / 16;
    
    // Create arrows based on count
    const arrows = [];
    
    if (arrowCount === 3) {
        // Normal tri-shot
        arrows.push(new Projectile(this.x, this.y, this.angle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + spreadAngle, weaponType, damage));
    } else {
        // Ricochet hexa-shot (6 arrows in a fan)
        const wideSpreadAngle = Math.PI / 12; // Wider spread for 6 arrows
        arrows.push(new Projectile(this.x, this.y, this.angle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - wideSpreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + wideSpreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - (wideSpreadAngle + spreadAngle), weaponType, damage));
    }
    
    // Apply ricochet properties if ready
    if (this.ricochetShotReady) {
        arrows.forEach(arrow => {
            arrow.ricochet = true;
            arrow.pierce = true;
            arrow.lifetime = 300; // 5 seconds
        });
        
        // Used the shot - start cooldown
        this.ricochetShotReady = false;
        this.ricochetCooldown = 1320; // 22 seconds
        floatingTexts.push(new FloatingText(this.x, this.y, 'RICOCHET!', '#16a34a', 14));
    }
    
    // Push all arrows to projectiles
    arrows.forEach(arrow => projectiles.push(arrow));
}
                    else if (this.type === 'ninja') {
    // NINJA SHURIKEN SLANT: Leon-style parallel spread
    weaponType = 'shuriken';
    cooldownFrames = 20;
    
    const damage = GAME_CONFIG.PROJECTILES.shuriken.damage * this.damageMult;
    const offsetDistance = 20; // Distance between parallel shurikens
    
    // Calculate perpendicular offset (90 degrees to aim direction)
    const perpAngle = this.angle + Math.PI / 2;
    const offsetX = Math.cos(perpAngle) * offsetDistance;
    const offsetY = Math.sin(perpAngle) * offsetDistance;
    
    // Shoot 3 parallel shurikens
    projectiles.push(new Projectile(this.x, this.y, this.angle, weaponType, damage)); // Center
    projectiles.push(new Projectile(this.x - offsetX, this.y - offsetY, this.angle, weaponType, damage)); // Top/Left
    projectiles.push(new Projectile(this.x + offsetX, this.y + offsetY, this.angle, weaponType, damage)); // Bottom/Right
}
else if (this.type === 'tempest') {
    // TEMPEST TRIPLE SHOT: Two curved boomerangs + 1 straight center shot
    weaponType = 'boomerang';
    cooldownFrames = 50;
    
    const damage = GAME_CONFIG.PROJECTILES.boomerang.damage * this.damageMult;
    const offsetDistance = 15;
    
    // Calculate perpendicular offset
    const perpAngle = this.angle + Math.PI / 2;
    const offsetX = Math.cos(perpAngle) * offsetDistance;
    const offsetY = Math.sin(perpAngle) * offsetDistance;
    
    // Shoot 2 curved boomerangs on the sides
    const boom1 = new Projectile(this.x + offsetX, this.y + offsetY, this.angle, 'boomerang', damage, 'top');
    const boom2 = new Projectile(this.x - offsetX, this.y - offsetY, this.angle, 'boomerang', damage, 'bottom');
    projectiles.push(boom1);
    projectiles.push(boom2);
    
    // Shoot 1 straight boomerang in the center (no curve)
    const boomCenter = new Projectile(this.x, this.y, this.angle, 'boomerang', damage, 'straight');
    projectiles.push(boomCenter);
    
    // Set weaponType to null so it doesn't create another projectile
    weaponType = null;
}

else if (this.type === 'zap') {
    weaponType = 'lightning';
    cooldownFrames = 20;
    
    // Build charge with each shot (1-5 charge per shot based on accuracy)
    if (!this.chargeCounter) this.chargeCounter = 0;
    this.chargeCounter += 3;
    
    const baseDamage = GAME_CONFIG.PROJECTILES.lightning.damage * this.damageMult;
    
    // Check if CHARGED (at 100 charge)
    const isCharged = this.chargeCounter >= 100;
    
    if (isCharged) {
        // CHARGED SHOT: Triple lightning bolts in spread pattern
        const spreadAngles = [this.angle - 0.15, this.angle, this.angle + 0.15];
        spreadAngles.forEach(angle => {
            const bolt = new Projectile(this.x, this.y, angle, 'lightning', baseDamage * 1.5);
            bolt.isCharged = true;
            bolt.color = '#fff'; // White lightning for charged
            projectiles.push(bolt);
        });
        
        floatingTexts.push(new FloatingText(this.x, this.y, 'CHARGED!', '#fbbf24', 18));
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 60, 'rgba(251, 191, 36, 0.8)', 'explosion'));
        
        this.chargeCounter = 0; // Reset charge
    } else {
        // NORMAL SHOT: Single lightning bolt
        const bolt = new Projectile(this.x, this.y, this.angle, 'lightning', baseDamage);
        projectiles.push(bolt);
    }
    
    weaponType = null;
}

else if (this.type === 'unit7') {
    if (this.currentMode === 'laser') {
        // LASER MODE: Powerful piercing shot with cooldown
        if (this.laserCooldown <= 0) {
            weaponType = 'corelaser';
            this.laserCooldown = 800; //  second cooldown ONLY for laser
            
            const laser = new Projectile(this.x, this.y, this.angle, 'corelaser', 
                GAME_CONFIG.PROJECTILES.corelaser.damage * this.damageMult);
            laser.pierce = true;
            laser.color = '#60a5fa';
            laser.w = 16;
            laser.h = 6;
            projectiles.push(laser);
            
            effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(96, 165, 250, 0.8)', 'explosion'));
            floatingTexts.push(new FloatingText(this.x, this.y, 'CORE BEAM!', '#60a5fa', 16));
            
            weaponType = null;
        }
    } else {
        // MICRO MODE: Rapid fire burst (NO COOLDOWN, only ammo)
        if (this.microAmmo > 0) {
            weaponType = 'microburst';
            this.microAmmo--;
            
            const micro = new Projectile(this.x, this.y, this.angle, 'microburst',
                GAME_CONFIG.PROJECTILES.microburst.damage * this.damageMult);
            micro.color = '#fbbf24';
            projectiles.push(micro);
            
            // Check if out of ammo
            if (this.microAmmo <= 0) {
                this.microCooldown = 180; // 3 second reload
                floatingTexts.push(new FloatingText(this.x, this.y, 'RELOADING!', '#ff6600', 10));
            }
            
            weaponType = null;
        } else {
            // Still reloading
            this.microCooldown--;
            if (this.microCooldown <= 0) {
                this.microAmmo = this.microMaxAmmo; // Refill ammo
            }
        }
    }
}
// Single projectile weapons (Mage only now, since Archer, Ninja, and Tempest handle their own)
if (weaponType && weaponType !== 'shuriken' && weaponType !== 'boomerang' && weaponType !== 'arrow') {
    projectiles.push(new Projectile(this.x, this.y, this.angle, weaponType, 
        GAME_CONFIG.PROJECTILES[weaponType].damage * this.damageMult));
}

// KNIGHT SHIELD WAVE ATTACK
if (this.type === 'knight' && this.shieldMode) {
    if (this.shieldWaveCooldown > 0) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'COOLDOWN!', '#ff6600', 12));
        return; // Don't shoot
    }
    
    // Activate shield wave
    this.shieldWaveCooldown = 600; // 10 seconds cooldown
    this.shieldWaveActive = true;
    
    // Create cone effect
    const waveRange = 150;
    const coneAngle = Math.PI / 4; // 45 degrees on each side
    
    // Find and slow enemies in cone
    let hitCount = 0;
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = (e.x + e.w/2) - (this.x + this.w/2);
        const dy = (e.y + e.h/2) - (this.y + this.h/2);
        const dist = Math.hypot(dx, dy);
        
        if (dist < waveRange) {
            const angleToEnemy = Math.atan2(dy, dx);
            let angleDiff = Math.abs(angleToEnemy - this.angle);
            if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
            
            // If enemy is within cone
            if (angleDiff < coneAngle) {
                // Apply slow
                if (!e.shieldSlowed) {
                    e.shieldSlowed = true;
                    e.originalSpeed = e.speed;
                    e.slowTimer = 120; // 2 seconds
                }
                e.speed = e.originalSpeed * 0.65; // 35% slow
                hitCount++;
            }
        }
    }
    
    // Visual effect
    effects.push({
        x: this.x + this.w/2,
        y: this.y + this.h/2,
        angle: this.angle,
        radius: 20,
        maxRadius: waveRange,
        life: 30,
        lifeMax: 30,
        type: 'shield_wave_cone',
        update: function() {
            this.life--;
            this.radius += 5;
        },
        draw: function() {
            if (this.life <= 0) return;
            const alpha = this.life / this.lifeMax;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // Draw cone
            ctx.fillStyle = `rgba(59, 130, 246, ${alpha * 0.4})`;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.radius, -Math.PI/4, Math.PI/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
        }
    });
    
    floatingTexts.push(new FloatingText(this.x, this.y, 'SHIELD WAVE!', '#3b82f6', 14));
    if (hitCount > 0) {
        floatingTexts.push(new FloatingText(this.x, this.y - 20, `HIT ${hitCount}!`, '#fbbf24', 12));
    }
    
    cooldownFrames = 0; // Don't apply normal cooldown
    return; // Exit shoot function
}

                 // Knight melee attack
if (this.type === 'knight') {
    // ‚úÖ FIX: Only attack if NOT in shield mode
    if (!this.shieldMode) {
        cooldownFrames = 70;
        this.isSlashing = true;
        this.slashTimer = 15; 
        
        const damage = GAME_CONFIG.PROJECTILES.sword.damage * this.damageMult;
        
        // Check collision along entire sword blade
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            
            // Check multiple points along the sword blade
            let hitDetected = false;
            for (let t = 0; t <= 1; t += 0.1) {
                const bladeX = this.x + this.w/2 + Math.cos(this.angle) * (this.swordLength * t);
                const bladeY = this.y + this.h/2 + Math.sin(this.angle) * (this.swordLength * t);
                
                // Check if this point on the blade overlaps enemy
                if (bladeX > e.x && bladeX < e.x + e.w && 
                    bladeY > e.y && bladeY < e.y + e.h) {
                    hitDetected = true;
                    break;
                }
            }
            
            // Also check if enemy is in front arc (backup check)
            const dx = (e.x + e.w/2) - (this.x + this.w/2);
            const dy = (e.y + e.h/2) - (this.y + this.h/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < this.swordLength + 30) {
                const angleToEnemy = Math.atan2(dy, dx);
                let diff = Math.abs(angleToEnemy - this.angle);
                if (diff > Math.PI) diff = 2*Math.PI - diff;
                if (diff < Math.PI/2) {
                    hitDetected = true;
                }
            }
            
            if (hitDetected) {
                hitEnemy(e, damage);
            }
        }
    }
}
                    
                    // Apply cooldown for all weapons EXCEPT Unit-7 (handles its own)
if (cooldownFrames > 0 && this.type !== 'unit7') {
    this.weaponCooldown = cooldownFrames / this.fireRateMult;
}
                }
            }
            
            class Enemy {
                constructor(x, y, type, difficultyMult) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.pushbackX = 0;
                    this.pushbackY = 0;
                    
                    const stats = GAME_CONFIG.ENEMIES[type];
                    
                    this.w = stats.size;
                    this.h = stats.size;
                    this.color = stats.color;
                    this.xpValue = stats.xp;
                    this.speed = stats.speed;
this.hp = stats.hp * difficultyMult;
                    this.maxHp = this.hp;

                    // Ranger enemy properties
if (type === 'ranger') {
    this.shootCooldown = 0;
    this.shootRange = stats.shootRange;
    this.shootCooldownMax = stats.shootCooldown;
}
                    
                    // Elite enemy properties
                    this.isElite = type.startsWith('elite_');
                    if (this.isElite) {
                        this.ability = stats.ability;
                        this.abilityCooldown = stats.abilityCooldown || 0;
                        this.abilityTimer = this.abilityCooldown;
                        this.isPhasing = false;
                        this.phaseTimer = 0;
                        this.isShielded = false;
                        this.shieldTimer = 0;
                        this.splitCount = stats.splitCount || 0;
                        this.glowPhase = 0;
                    }
 }
                
                draw() {
                    this.x += this.pushbackX;
                    this.y += this.pushbackY;
                    this.pushbackX *= 0.8;
                    this.pushbackY *= 0.8;

// ELITE ENEMY RENDERING
if (this.isElite) {
    this.glowPhase += 0.1;
    const glowIntensity = Math.sin(this.glowPhase) * 0.3 + 0.7;
    
    // Elite glow aura
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15 * glowIntensity;
    
    // Phasing Specter
    if (this.type === 'elite_specter') {
        if (this.isPhasing) {
            ctx.globalAlpha = 0.3;
            ctx.shadowBlur = 25;
        }
        
        // Specter body with trail effect
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2, 0, Math.PI * 2);
        ctx.fill();
        
        // Ghost eyes
        ctx.fillStyle = '#ffffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2 - 6, this.y + this.h/2 - 4, 4, 0, Math.PI * 2);
        ctx.arc(this.x + this.w/2 + 6, this.y + this.h/2 - 4, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Purple energy wisps
        for (let i = 0; i < 3; i++) {
            const angle = this.glowPhase + (i * Math.PI * 2 / 3);
            const wispX = this.x + this.w/2 + Math.cos(angle) * 20;
            const wispY = this.y + this.h/2 + Math.sin(angle) * 20;
            ctx.fillStyle = `rgba(147, 51, 234, ${0.4 * glowIntensity})`;
            ctx.beginPath();
            ctx.arc(wispX, wispY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }
    
    // Tank with Shield
    else if (this.type === 'elite_tank') {
        // Tank body
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // Armor plates
        ctx.fillStyle = '#1e3a8a';
        const plateSize = 8;
        for (let py = 0; py < this.h; py += plateSize + 2) {
            for (let px = 0; px < this.w; px += plateSize + 2) {
                ctx.fillRect(this.x + px, this.y + py, plateSize, plateSize);
            }
        }
        
        // Shield effect when active
        if (this.isShielded) {
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#60a5fa';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2 + 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Hexagonal shield pattern
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + this.glowPhase;
                const x = this.x + this.w/2 + Math.cos(angle) * (this.w/2 + 6);
                const y = this.y + this.h/2 + Math.sin(angle) * (this.w/2 + 6);
                ctx.fillStyle = `rgba(96, 165, 250, ${0.6 * glowIntensity})`;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.lineWidth = 1;
    }
    
    // Splitter
    else if (this.type === 'elite_splitter') {
        // Main body with segmented appearance
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // Segmentation lines
        ctx.strokeStyle = '#052e16';
        ctx.lineWidth = 2;
        const segments = 3;
        for (let i = 1; i < segments; i++) {
            const segY = this.y + (this.h / segments) * i;
            ctx.beginPath();
            ctx.moveTo(this.x, segY);
            ctx.lineTo(this.x + this.w, segY);
            ctx.stroke();
        }
        
        // Pulsing core
        const coreSize = 6 + Math.sin(this.glowPhase * 2) * 2;
        ctx.fillStyle = '#22c55e';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#22c55e';
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2, coreSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    
    // Health bar for elites
    if (this.hp < this.maxHp) {
        const barY = this.y - 12;
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x - 2, barY, this.w + 4, 8);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, barY + 1, (this.w * (this.hp/this.maxHp)), 6);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x - 2, barY, this.w + 4, 8);
    }
    
    return;
}

// BOSS RENDERING
if (this.isBoss) {
    // Expanded hitbox (easier to hit)

    
    // CHRISTMAS FESTIVE BOSS
    if (saveData.christmasMode) {
        // Santa Boss!
        ctx.fillStyle = '#000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 30;
        ctx.fillRect(this.x - 4, this.y - 4, this.w + 8, this.h + 8);
        
        // Red body
        ctx.fillStyle = '#dc2626';
        ctx.shadowBlur = 20;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // White belt
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.fillRect(this.x, this.y + this.h/2 - 10, this.w, 20);
        
        // Gold buckle
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(this.x + this.w/2 - 15, this.y + this.h/2 - 8, 30, 16);
        
        // Santa hat on top
        ctx.save();
        ctx.font = '40px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('üéÖ', this.x + this.w/2, this.y - 10);
        ctx.restore();
} else {
        // Wave 15+ = Dark red menacing boss
        if (wave >= 5) {
            ctx.fillStyle = '#000';
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 40;
            ctx.fillRect(this.x - 6, this.y - 6, this.w + 12, this.h + 12);
            
            // Dark red body with glowing veins
            ctx.fillStyle = '#7f1d1d';
            ctx.shadowBlur = 25;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // Glowing red veins
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#dc2626';
            for(let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + (i * 16));
                ctx.lineTo(this.x + this.w, this.y + (i * 16) + 8);
                ctx.stroke();
            }
            
            // Red glowing eyes
            ctx.fillStyle = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(this.x + 30, this.y + 30, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x + 70, this.y + 30, 8, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Normal purple boss (waves 5-10)
            ctx.fillStyle = '#000';
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 30;
            ctx.fillRect(this.x - 4, this.y - 4, this.w + 8, this.h + 8);
            
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 0;
            for(let i = 0; i < 5; i++) {
                ctx.fillRect(this.x, this.y + (i * 20), this.w, 8);
            }
        }
    }
    
    // Boss health bar at top of screen
    const barWidth = canvas.width * 0.6;
    const barX = canvas.width * 0.2;
    const barY = 20;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(barX - 2, barY - 2, barWidth + 4, 24);
    
    ctx.fillStyle = saveData.christmasMode ? '#dc2626' : '#581c87';
    ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), 20);
    
    ctx.strokeStyle = saveData.christmasMode ? '#ff0000' : '#a855f7';
    ctx.lineWidth = 3;
    ctx.strokeRect(barX, barY, barWidth, 20);
    
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(saveData.christmasMode ? 'EVIL SANTA' : 'BOSS', canvas.width / 2, barY - 8);
    ctx.textAlign = 'left';
    
    ctx.shadowBlur = 0;
    return;
}
// Apply map tint to enemies
let enemyColor = this.color;
if (currentMap && GAME_CONFIG.MAPS[currentMap].enemyTint) {
    const tint = GAME_CONFIG.MAPS[currentMap].enemyTint;
    // Blend enemy color with map tint
    enemyColor = this.color;
}
ctx.fillStyle = enemyColor;
ctx.shadowColor = 'black';
ctx.shadowBlur = 5;
if (this.type === 'frosty') {
    ctx.beginPath();
    ctx.moveTo(this.x + this.w/2, this.y);
    ctx.lineTo(this.x + this.w, this.y + this.h/2);
    ctx.lineTo(this.x + this.w/2, this.y + this.h);
    ctx.lineTo(this.x, this.y + this.h/2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(this.x + this.w/2, this.y+8);
    ctx.lineTo(this.x + this.w-8, this.y + this.h/2);
    ctx.lineTo(this.x + this.w/2, this.y + this.h-8);
    ctx.lineTo(this.x+8, this.y + this.h/2);
    ctx.fill();
} else {
    ctx.fillRect(this.x, this.y, this.w, this.h);
    if(this.type === 'brute') {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(this.x+5, this.y+5, this.w-10, this.h-10);
    }
}

// Ranger indicator
if (this.type === 'ranger') {
    ctx.fillStyle = '#eab308';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#eab308';
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x + 8, this.y + 8, 8, 8);
    ctx.shadowBlur = 0;
}

// FIXED: Health bar for ALL enemy types (including frosty)
if (this.hp < this.maxHp) {
    ctx.fillStyle = 'black';
    ctx.fillRect(this.x, this.y - 10, this.w, 6);
    ctx.fillStyle = this.type === 'frosty' ? '#06b6d4' : '#0f0'; // Cyan for frosty
    ctx.fillRect(this.x + 1, this.y - 9, (this.w - 2) * (this.hp/this.maxHp), 4);
}
                    ctx.shadowBlur = 0;
}
                
update() {

    // Handle stun
    if (this.isStunned && this.stunTimer !== undefined) {
        this.stunTimer--;
        if (this.stunTimer <= 0) {
            this.isStunned = false;
            this.speed = this.originalSpeed;
        }
        // Draw stars around stunned enemy
        if (frameCount % 10 === 0) {
            for (let i = 0; i < 3; i++) {
                const angle = (frameCount * 0.1) + (i * Math.PI * 2 / 3);
                const starX = this.x + this.w/2 + Math.cos(angle) * 30;
                const starY = this.y + this.h/2 + Math.sin(angle) * 30;
                floatingTexts.push(new FloatingText(starX, starY, '‚≠ê', '#fbbf24', 12));
            }
        }
    }

// Handle shield slow timer
    if (this.slowTimer !== undefined && this.slowTimer > 0) {
        this.slowTimer--;
        if (this.slowTimer <= 0 && this.shieldSlowed) {
            this.speed = this.originalSpeed;
            this.shieldSlowed = false;
            delete this.slowTimer; // Clean up
        }
    }
   
    
    // Elite ability logic
    if (this.isElite) {
                        this.abilityTimer--;
                        
                        // Specter Phase ability
                        if (this.type === 'elite_specter') {
                            if (this.isPhasing) {
                                this.phaseTimer--;
                                if (this.phaseTimer <= 0) {
                                    this.isPhasing = false;
                                }
                            } else if (this.abilityTimer <= 0) {
                                this.isPhasing = true;
                                this.phaseTimer = 60; // 1 second of phasing
                                this.abilityTimer = this.abilityCooldown;
                                effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(147, 51, 234, A)', 'explosion'));
                            }
                        }
                        
                        // Tank Shield ability
                        if (this.type === 'elite_tank') {
                            if (this.isShielded) {
                                this.shieldTimer--;
                                if (this.shieldTimer <= 0) {
                                    this.isShielded = false;
                                }
                            } else if (this.abilityTimer <= 0 && this.hp < this.maxHp * 0.7) {
                                this.isShielded = true;
                                this.shieldTimer = 120; // 2 seconds of shield
                                this.abilityTimer = this.abilityCooldown;
                                effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 50, 'rgba(96, 165, 250, A)', 'explosion'));
                            }
                        }
                    }

                    // Ranger shooting logic (BUFFED)
if (this.type === 'ranger' && player) {
    const dist = Math.hypot((player.x + player.w/2) - (this.x + this.w/2), 
                            (player.y + player.h/2) - (this.y + this.h/2));
    
    if (dist < this.shootRange) {
        this.shootCooldown--;
        if (this.shootCooldown <= 0) {
            const angle = Math.atan2((player.y + player.h/2) - (this.y + this.h/2), 
                                    (player.x + player.w/2) - (this.x + this.w/2));
            const stats = GAME_CONFIG.ENEMIES.ranger;
            const enemyProj = new Projectile(this.x + this.w/2, this.y + this.h/2, angle, 'turret', stats.projectileDamage);
            enemyProj.color = '#eab308';
            enemyProj.w = stats.projectileSize;
            enemyProj.h = stats.projectileSize;
            enemyProj.speed = stats.projectileSpeed;
            enemyProj.isEnemyProjectile = true;
            projectiles.push(enemyProj);
            effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 20, 'rgba(234, 179, 8, 0.6)', 'explosion'));
            this.shootCooldown = this.shootCooldownMax;
        }
    }
}
                    
                
                    let speed = this.speed;
                    for (const effect of effects) {
                        if (effect.type === 'ice_field') {
                            const dist = Math.hypot((this.x+this.w/2)-effect.x, (this.y+this.h/2)-effect.y);
                            if (dist < effect.radius) speed *= 0.4;
                        }
                    }
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                   const dist = Math.sqrt(dx*dx + dy*dy);

// BOSS ENRAGE: Speed increases at 50% HP
if (this.isBoss && this.hp < this.maxHp * 0.5) {
    speed *= 1.5; // 50% faster when below half HP
    
    // Visual warning effect (only once)
    if (!this.hasEnraged) {
        this.hasEnraged = true;
        floatingTexts.push(new FloatingText(this.x, this.y, 'ENRAGED!', '#ff0000', 24));
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 150, 'rgba(255, 0, 0, 0.8)', 'explosion'));
    }
}
// BOSS ENRAGE: Create expanding fire ring that burns players (ONCE ONLY)
if (this.isBoss && this.hp < this.maxHp * 0.5 && !this.hasSpawnedFireRing) {
    this.hasSpawnedFireRing = true; // Mark as spawned
    
    // Create expanding fire ring effect (DECAYS AFTER 15 SECONDS)
    effects.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 0,
        maxRadius: Math.min(canvas.width, canvas.height) / 2 - 50,
        life: 900, // 15 seconds at 60fps
        lifeMax: 900,
        damage: 3,
        type: 'boss_fire_ring',
        update: function() {
            this.life--;
            if (this.radius < this.maxRadius) {
                this.radius += 8;
            }
            
            // Only burn if fire ring exists
            if (this.life <= 0) return;
            
            // Burn player if outside safe zone
            if (player && player.hp > 0) {
                const distFromCenter = Math.hypot(
                    (player.x + player.w/2) - this.x,
                    (player.y + player.h/2) - this.y
                );
                
                if (distFromCenter > this.radius && frameCount % 15 === 0) {
                    player.hp -= this.damage;
                    floatingTexts.push(new FloatingText(player.x, player.y, 'üî• BURN!', '#ff6600', 14));
                    effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 30, 'rgba(255, 100, 0, 0.6)', 'explosion'));
                    player.updateUI();
                    
                    if (player.hp <= 0) {
                        endGame();
                    }
                }
            }
        },
        draw: function() {
            if (this.life <= 0) return;
            
            const alpha = Math.min(0.8, this.life / this.lifeMax);
            
            // FIXED: Prevent negative radius
            const drawRadius = Math.max(0, this.radius);
            
            // Draw fire ring at edge
            ctx.save();
            ctx.strokeStyle = `rgba(255, 100, 0, ${alpha})`;
            ctx.lineWidth = 30;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(this.x, this.y, drawRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner glow
            if (drawRadius >= 10) {
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 15;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawRadius - 10, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Flame particles
            if (frameCount % 3 === 0 && drawRadius > 0) {
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const flameX = this.x + Math.cos(angle) * drawRadius;
                    const flameY = this.y + Math.sin(angle) * drawRadius;
                    const flicker = Math.random() * 10 - 5;
                    
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(flameX + flicker, flameY + flicker, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    });
    
    floatingTexts.push(new FloatingText(canvas.width/2 - 80, 100, 'üî• FIRE RING!', '#ff6600', 24));
}

if (dist > 0) {
    this.x += (dx/dist) * speed;
    this.y += (dy/dist) * speed;
}
                    this.draw();
                }
                takeDamage(amt) {
                    this.hp -= amt;
                    this.pushbackX = (Math.random() - 0.5) * 6;
                    this.pushbackY = (Math.random() - 0.5) * 6;
                    floatingTexts.push(new FloatingText(this.x, this.y, Math.round(amt), '#fff'));
                    if (this.hp <= 0) return true;
                    return false;
                }
            }
            
            class Projectile {
    constructor(x, y, angle, type, damage, curveDirection = null) {
        this.x = x + GAME_CONFIG.PLAYER.BASE_SIZE/2;
        this.y = y + GAME_CONFIG.PLAYER.BASE_SIZE/2;
        this.type = type;
        this.angle = angle;
        this.damage = damage;
        this.curveDirection = curveDirection; // 'top' or 'bottom' for boomerangs
        this.distanceTraveled = 0;
                    
                    const stats = GAME_CONFIG.PROJECTILES[type];
                    this.w = stats.size;
                    this.h = stats.size;
                    this.speed = stats.speed;
                    this.knockback = stats.knockback || 0;
                    this.knockback = stats.knockback || 0;
                    
                    // Ricochet properties
                    this.ricochet = false;
                    this.pierce = false;
                    this.lifetime = null;
                    this.bounceCount = 0;
                    this.maxBounces = 8;
                    
                    if (type === 'fireball') { this.color = '#f97316'; }
                    
                    if (type === 'fireball') { this.color = '#f97316'; }
                    else if (type === 'turret') { this.color = '#fbbf24'; }
                    else if (type === 'arrow') { this.color = '#a3e635'; this.w = 8; this.h = 20; }
                    else if (type === 'shuriken') { this.color = '#fff'; this.w = 12; this.h = 12; } // White for shuriken
            
else if (type === 'boomerang') { 
    this.color = '#6dd5ed'; 
    this.w = 16; 
    this.h = 16; 
    this.curveCount = 0; // Track how much it's curved for bonus damage
    this.lifetimeFrames = 0; // Track how long it's been alive (renamed to avoid conflict)
    this.curveDirection = curveDirection; // Store the curve direction
}

else if (type === 'lightning') {
    this.color = '#fbbf24';
    this.w = 10;
    this.h = 10;
}

                }
              draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // PIERCING GLOW - Show when piercing is active
    if (player && player.upgrades.piercingShots > 0) {
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 15;
    }
    
    if (this.type === 'shuriken') {
        ctx.rotate(this.angle + (frameCount * 0.3));
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, -this.h/2);
        ctx.lineTo(this.w/2, 0);
        ctx.lineTo(0, this.h/2);
        ctx.lineTo(-this.w/2, 0);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(0,0,2,0,Math.PI*2);
        ctx.fill();
    } 
    else if (this.type === 'turret') {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0,0,4,0,Math.PI*2);
        ctx.fill();
    } 
    else if (this.type === 'boomerang') {
        ctx.rotate(this.angle + (frameCount * 0.2));
        ctx.strokeStyle = '#6dd5ed';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#6dd5ed';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 8, Math.PI, Math.PI * 2);
        ctx.stroke();
    } 
    else if (this.type === 'lightning') {
        ctx.rotate(this.angle);
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = this.isOverload ? 25 : 15;
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = this.isOverload ? 6 : 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'miter';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(12, -4);
        ctx.lineTo(8, 0);
        ctx.lineTo(20, -2);
        ctx.lineTo(14, 2);
        ctx.lineTo(24, 0);
        ctx.lineTo(16, 4);
        ctx.lineTo(28, 3);
        ctx.stroke();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = this.isOverload ? 3 : 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(12, -4);
        ctx.lineTo(8, 0);
        ctx.lineTo(20, -2);
        ctx.lineTo(14, 2);
        ctx.lineTo(24, 0);
        ctx.lineTo(16, 4);
        ctx.lineTo(28, 3);
        ctx.stroke();
        if (Math.random() < 0.3) {
            for (let i = 0; i < 3; i++) {
                const sparkX = Math.random() * 28;
                const sparkY = (Math.random() - 0.5) * 8;
                ctx.fillStyle = this.isOverload ? '#fff' : '#fbbf24';
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, Math.random() * 2 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    } 
    else {
        ctx.rotate(this.angle + Math.PI/2);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
    }
    
    ctx.restore();
}
             update() {
// Boomerang curving logic
if (this.type === 'boomerang') {
    this.lifetimeFrames++;
    this.distanceTraveled += this.speed;
    
    // SHORTER LIFESPAN: Disappear after 180 frames (3 seconds)
    if (this.lifetimeFrames > 180) {
        return true; // Signal for removal
    }
    
    // Start curving after traveling 80 pixels (EXCEPT for straight shots)
    if (this.distanceTraveled > 80 && this.curveDirection !== 'straight') {
        const curveRate = GAME_CONFIG.PROJECTILES.boomerang.curveRate;
        if (this.curveDirection === 'top') {
            this.angle -= curveRate; // Curve outward (up)
            this.curveCount += curveRate; // Track curving
        } else if (this.curveDirection === 'bottom') {
            this.angle += curveRate; // Curve outward (down)
            this.curveCount += curveRate; // Track curving
        }
            // BONUS DAMAGE: More curve = more damage
            const bonusDamage = this.curveCount * GAME_CONFIG.PROJECTILES.boomerang.bonusDamagePerCurve;
            this.currentDamage = this.damage + bonusDamage;
        } else {
            this.currentDamage = this.damage;
        }
    }
    
    // Handle ricochet lifetime
    if (this.lifetime !== null) {
        this.lifetime--;
        if (this.lifetime <= 0) {
            return true; // Remove arrow
        }
    }
    
    // Move projectile
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    
    // RICOCHET OFF WALLS
    if (this.ricochet && this.bounceCount < this.maxBounces) {
        let bounced = false;
        
        // Check canvas boundaries
        if (this.x < 0 || this.x > canvas.width) {
            this.angle = Math.PI - this.angle; // Reflect horizontally
            this.x = Math.max(0, Math.min(canvas.width, this.x));
            bounced = true;
        }
        if (this.y < 0 || this.y > canvas.height) {
            this.angle = -this.angle; // Reflect vertically
            this.y = Math.max(0, Math.min(canvas.height, this.y));
            bounced = true;
        }
        
        if (bounced) {
            this.bounceCount++;
            effects.push(new Effect(this.x, this.y, 15, 'rgba(22, 163, 74, A)', 'explosion'));
        }
    }
    
    this.draw();
}
            }
            
           class Effect {
    constructor(x, y, radius, color, type) {
        this.x = x; this.y = y; this.type = type;
        this.maxRadius = radius; this.color = color;
        if (type === 'explosion') {
            this.radius = 10; this.life = 15; this.lifeMax = 15;
        } else if (type === 'expanding_wind_wave') {
            this.radius = 30;
            this.life = 60;
            this.lifeMax = 60;
            this.expandSpeed = 15;
        } else if (type === 'trail') {
            this.radius = radius;
            this.life = 20; // Short-lived trail
            this.lifeMax = 20;
        } else {
            this.radius = radius; this.life = 180; this.lifeMax = 180;
        }
    }
              update() {
    if (this.type === 'explosion') {
        this.radius += (this.maxRadius - this.radius) * 0.2;
    } else if (this.type === 'expanding_wind_wave') {
        this.radius += this.expandSpeed;
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
            
            const waveThickness = 40;
            if (dist >= this.radius - waveThickness && dist <= this.radius + waveThickness) {
                if (!e.hitByWave || e.hitByWave !== this) {
                    hitEnemy(e, 5);
                    e.hitByWave = this;
                    
                    const angle = Math.atan2((e.y + e.h/2) - this.y, (e.x + e.w/2) - this.x);
                    e.pushbackX = Math.cos(angle) * 25;
                    e.pushbackY = Math.sin(angle) * 25;
                }
            }
        }
} else if (this.type === 'poison') {
    // Poison clouds damage enemies inside - FIXED (moved from enemy update)
    if (frameCount % 30 === 0 && player && player.upgrades.poisonTrail > 0) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (!e) continue; // Safety check
            const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
            if (dist < this.radius) {
                hitEnemy(e, 0.8 * player.upgrades.poisonTrail);
                floatingTexts.push(new FloatingText(e.x, e.y, '‚ò†Ô∏è', '#22c55e', 10));
            }
        }
    }
}

else if (this.type === 'shield_wave') {
    // Shield wave slows enemies in cone
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e) continue;
        
        // Check if enemy is in cone range
        const dx = (e.x + e.w/2) - this.x;
        const dy = (e.y + e.h/2) - this.y;
        const dist = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        
        let angleDiff = Math.abs(angleToEnemy - this.angle);
        if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
        
       // If within cone and range, apply slow
if (dist < this.radius && angleDiff < Math.PI/4) {
    if (!e.shieldSlowed) {
        e.shieldSlowed = true;
        e.originalSpeed = e.speed;
    }
    e.speed = e.originalSpeed * 0.2; // 80% slow (even stronger)
e.slowDuration = 240; // 4 seconds instead of 2
} else if (e.shieldSlowed) {
    e.speed = e.originalSpeed;
    e.shieldSlowed = false;
}
    }
}


    this.life--;
}


                                draw() {
                    const alpha = (this.life / this.lifeMax) * (this.type === 'explosion' ? 0.8 : 0.3);
                    ctx.save();
                    ctx.fillStyle = this.color.replace('A', alpha);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    if (this.type === 'ice_field') {
                        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        if (Math.random() < 0.2) {
                            ctx.fillStyle = 'white';
                            const rx = (Math.random() - 0.5) * this.radius * 1.5;
                            const ry = (Math.random() - 0.5) * this.radius * 1.5;
                            ctx.fillRect(this.x + rx, this.y + ry, 2, 2);
                        }
                    }
                    if (this.type === 'wind_wave') {
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
        ctx.lineWidth = 4;
        ctx.stroke();
        // Add swirl lines
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - (i * 15), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.5})`;
            ctx.stroke();
        }
    }

   if (this.type === 'poison') {
        // Green toxic cloud with animated bubbles
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
        gradient.addColorStop(0, `rgba(34, 197, 94, ${alpha * 0.7})`);
        gradient.addColorStop(0.5, `rgba(22, 163, 74, ${alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(21, 128, 61, ${alpha * 0.2})`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Animated poison bubbles
        if (Math.random() < 0.4) {
            for (let i = 0; i < 3; i++) {
                const angle = (frameCount * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                const bubbleX = this.x + Math.cos(angle) * (this.radius * 0.6);
                const bubbleY = this.y + Math.sin(angle) * (this.radius * 0.6);
                const bubbleSize = 3 + Math.sin(frameCount * 0.1 + i) * 2;
                
                ctx.fillStyle = `rgba(134, 239, 172, ${alpha * 0.9})`;
                ctx.shadowColor = '#22c55e';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }
    }

    ctx.restore();
                }
            }

            
        

            // --- CORE FUNCTIONS ---
            // --- CORE FUNCTIONS ---

            function generateMapObjects(mapType) {
    mapObjects = [];
    const mapData = GAME_CONFIG.MAPS[mapType];
    
    if (mapType === 'forest') {
        // Generate trees
        for (let i = 0; i < mapData.treeCount; i++) {
            mapObjects.push({
                type: 'tree',
                x: Math.random() * (canvas.width - 60) + 30,
                y: Math.random() * (canvas.height - 60) + 30,
                size: 20 + Math.random() * 20,
                sway: Math.random() * Math.PI * 2,
                draw: function() {
                    this.sway += 0.02;
                    const swayOffset = Math.sin(this.sway) * 3;
                    
                    // Tree trunk
                    ctx.fillStyle = '#3d2817';
                    ctx.fillRect(this.x - 5 + swayOffset, this.y, 10, this.size);
                    
                    // Tree crown
                    ctx.fillStyle = '#1a5c1a';
                    ctx.shadowColor = '#0a3d0a';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x + swayOffset, this.y - 10, this.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Highlights
                    ctx.fillStyle = '#2d7c2d';
                    ctx.beginPath();
                    ctx.arc(this.x - 8 + swayOffset, this.y - 15, this.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
    if (mapType === 'desert') {
        // Generate cacti
        for (let i = 0; i < mapData.cactusCount; i++) {
            mapObjects.push({
                type: 'cactus',
                x: Math.random() * (canvas.width - 40) + 20,
                y: Math.random() * (canvas.height - 40) + 20,
                height: 30 + Math.random() * 20,
                draw: function() {
                    // Cactus body
                    ctx.fillStyle = '#2d6b2d';
                    ctx.fillRect(this.x - 8, this.y, 16, this.height);
                    
                    // Arms
                    ctx.fillRect(this.x - 20, this.y + 15, 12, 3);
                    ctx.fillRect(this.x - 20, this.y + 15, 3, 15);
                    ctx.fillRect(this.x + 8, this.y + 20, 12, 3);
                    ctx.fillRect(this.x + 17, this.y + 20, 3, 12);
                    
                    // Spines
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    for (let s = 0; s < 5; s++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x - 8, this.y + s * 8);
                        ctx.lineTo(this.x - 12, this.y + s * 8);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(this.x + 8, this.y + s * 8);
                        ctx.lineTo(this.x + 12, this.y + s * 8);
                        ctx.stroke();
                    }
                }
            });
        }
        
        // Add sand dunes
        for (let i = 0; i < 5; i++) {
            mapObjects.push({
                type: 'dune',
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: 50 + Math.random() * 50,
                draw: function() {
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
    if (mapType === 'ice') {
        // Generate ice crystals
        for (let i = 0; i < mapData.crystalCount; i++) {
            mapObjects.push({
                type: 'crystal',
                x: Math.random() * (canvas.width - 40) + 20,
                y: Math.random() * (canvas.height - 40) + 20,
                height: 25 + Math.random() * 25,
                sparkle: Math.random() * Math.PI * 2,
                draw: function() {
                    this.sparkle += 0.05;
                    const glowAlpha = 0.3 + Math.sin(this.sparkle) * 0.2;
                    
                    // Crystal glow
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 15;
                    
                    // Crystal shape
                    ctx.fillStyle = `rgba(150, 220, 255, ${glowAlpha + 0.5})`;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height);
                    ctx.lineTo(this.x - 10, this.y);
                    ctx.lineTo(this.x + 10, this.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height + 5);
                    ctx.lineTo(this.x - 5, this.y - 5);
                    ctx.lineTo(this.x + 5, this.y - 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Add snowflakes
        for (let i = 0; i < 20; i++) {
            mapObjects.push({
                type: 'snowflake',
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: 0.5 + Math.random() * 1,
                rotation: Math.random() * Math.PI * 2,
                draw: function() {
                    this.y += this.speed;
                    this.rotation += 0.02;
                    if (this.y > canvas.height) this.y = -10;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ùÑ', 0, 0);
                    ctx.restore();
                }
            });
        }
    }
    
    if (mapType === 'volcano') {
        // Generate lava pools
        for (let i = 0; i < mapData.lavaPoolCount; i++) {
            mapObjects.push({
                type: 'lava',
                x: Math.random() * (canvas.width - 80) + 40,
                y: Math.random() * (canvas.height - 80) + 40,
                radius: 30 + Math.random() * 20,
                bubble: 0,
                draw: function() {
                    this.bubble += 0.1;
                    
                    // Outer glow
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                    gradient.addColorStop(0, '#ff4500');
                    gradient.addColorStop(0.5, '#ff6600');
                    gradient.addColorStop(1, 'rgba(139, 0, 0, 0.3)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bubbles
                    for (let b = 0; b < 3; b++) {
                        const bubblePhase = this.bubble + (b * Math.PI * 2 / 3);
                        const bubbleY = this.y + Math.sin(bubblePhase) * 5;
                        ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x + Math.cos(b) * 10, bubbleY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        
        // Add smoke particles
        for (let i = 0; i < 15; i++) {
            mapObjects.push({
                type: 'smoke',
                x: Math.random() * canvas.width,
                y: canvas.height + Math.random() * 50,
                speed: 0.3 + Math.random() * 0.5,
                size: 10 + Math.random() * 15,
                alpha: 0.1 + Math.random() * 0.2,
                draw: function() {
                    this.y -= this.speed;
                    this.alpha -= 0.001;
                    if (this.y < -20 || this.alpha <= 0) {
                        this.y = canvas.height + 10;
                        this.alpha = 0.1 + Math.random() * 0.2;
                    }
                    
                    ctx.fillStyle = `rgba(100, 100, 100, ${this.alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
if (mapType === 'swamp') {
    // Generate dead trees
    for (let i = 0; i < mapData.treeCount; i++) {
        mapObjects.push({
            type: 'dead_tree',
            x: Math.random() * (canvas.width - 40) + 20,
            y: Math.random() * (canvas.height - 60) + 30,
            height: 30 + Math.random() * 20,
            draw: function() {
                // Dead tree trunk (dark gray)
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(this.x - 4, this.y, 8, this.height);
                
                // Twisted branches
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 10);
                ctx.lineTo(this.x - 12, this.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 15);
                ctx.lineTo(this.x + 10, this.y + 5);
                ctx.stroke();
            }
        });
    }
    
    // Add fog particles
    for (let i = 0; i < 25; i++) {
        mapObjects.push({
            type: 'fog',
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 40 + Math.random() * 40,
            speed: 0.2 + Math.random() * 0.3,
            alpha: 0.1 + Math.random() * 0.15,
            draw: function() {
                this.x += this.speed;
                if (this.x > canvas.width + 50) this.x = -50;
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, `rgba(200, 220, 200, ${this.alpha})`);
                gradient.addColorStop(1, 'rgba(200, 220, 200, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
    
    // Add murky water puddles
    for (let i = 0; i < 8; i++) {
        mapObjects.push({
            type: 'puddle',
            x: Math.random() * (canvas.width - 60) + 30,
            y: Math.random() * (canvas.height - 60) + 30,
            radius: 25 + Math.random() * 20,
            ripple: 0,
            draw: function() {
                this.ripple += 0.05;
                
                // Dark water
                ctx.fillStyle = '#1a3a2a';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ripple effect
                const rippleRadius = this.radius * (0.8 + Math.sin(this.ripple) * 0.2);
                ctx.strokeStyle = 'rgba(100, 150, 120, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, rippleRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    }
}
}

function initMusic() {
    backgroundMusic = new Audio();
    backgroundMusic.src = 'game-music.mp3';
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.15;
    
    if (musicEnabled) {
        backgroundMusic.play().catch(e => console.log('Click to start music'));
    }
}

function toggleMusic() {
    musicEnabled = !musicEnabled;
    const btn = document.getElementById('musicToggle');
    
    if (musicEnabled) {
        btn.textContent = 'ON';
        btn.className = 'game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white';
        if (backgroundMusic) backgroundMusic.play().catch(e => {});
    } else {
        btn.textContent = 'OFF';
        btn.className = 'game-btn px-4 py-2 text-xs bg-red-500 border-red-700 text-white';
        if (backgroundMusic) backgroundMusic.pause();
    }
}
function toggleChristmas() {
    saveData.christmasMode = !saveData.christmasMode;
    saveDataToStorage();
    applyChristmasMode();
}

function applyChristmasMode() {
    const btn = document.getElementById('christmasToggle');
    const body = document.body;
    const title = document.getElementById('gameTitle');
    
    if (saveData.christmasMode) {
        btn.textContent = 'ON';
        btn.className = 'game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white';
        
        // ‚ùÑÔ∏è CHRISTMAS BACKGROUND
        body.style.background = 'linear-gradient(180deg, #1a2332 0%, #2d3e50 50%, #4a5f7f 100%)';
        body.style.position = 'relative';
        
        // Create snowflakes container if it doesn't exist
        if (!document.getElementById('snowflakes')) {
            const snowContainer = document.createElement('div');
            snowContainer.id = 'snowflakes';
            snowContainer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;';
            body.appendChild(snowContainer);
            
            // Create 50 snowflakes
            for (let i = 0; i < 50; i++) {
                const snowflake = document.createElement('div');
                snowflake.innerHTML = '‚ùÑÔ∏è';
                snowflake.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: ${Math.random() * 100}%;
                    font-size: ${Math.random() * 10 + 10}px;
                    opacity: ${Math.random() * 0.7 + 0.3};
                    animation: fall ${Math.random() * 3 + 5}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                `;
                snowContainer.appendChild(snowflake);
            }
            
            // Add snowfall animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fall {
                    to {
                        transform: translateY(100vh) rotate(360deg);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // üéÖ FESTIVE TITLE
        title.textContent = 'üéÑ BLOCKY XMAS üéÅ';
        title.style.color = '#ff4444';
        title.style.textShadow = '4px 4px 0 #00ff00, 8px 8px 0 rgba(255,255,255,0.3)';
        
    } else {
        btn.textContent = 'OFF';
        btn.className = 'game-btn px-4 py-2 text-xs bg-red-500 border-red-700 text-white';
        
        // Remove Christmas effects
        body.style.background = '#111';
        const snowContainer = document.getElementById('snowflakes');
        if (snowContainer) snowContainer.remove();
        
        // Reset title
        title.textContent = 'BLOCKY LEGENDS';
        title.style.color = '#fbbf24';
        title.style.textShadow = '4px 4px 0 rgba(0,0,0,1)';
    }
}

// =====================================================
// CHRISTMAS EVENT FUNCTIONS
// =====================================================
// Create animated snowfall effect
function createSnowfall() {
    // Remove existing snowflakes
    const existing = document.querySelectorAll('.snowflake');
    existing.forEach(s => s.remove());
    
    // Only create if on Christmas screen
    if (!screens.christmas.classList.contains('hidden')) {
        for (let i = 0; i < 30; i++) {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.textContent = '‚ùÑÔ∏è';
            snowflake.style.left = Math.random() * 100 + '%';
            snowflake.style.animationDuration = (Math.random() * 3 + 4) + 's';
            snowflake.style.animationDelay = Math.random() * 5 + 's';
            snowflake.style.fontSize = (Math.random() * 10 + 15) + 'px';
            document.body.appendChild(snowflake);
        }
    }
}

function updateChristmasUI() {
    document.getElementById('snowflakeCount').textContent = saveData.snowflakes || 0;
    
    // Update present buttons
    document.getElementById('buyBasicPresent').disabled = (saveData.snowflakes || 0) < 10;
    document.getElementById('buyPremiumPresent').disabled = (saveData.snowflakes || 0) < 25;
    document.getElementById('buyLegendaryPresent').disabled = (saveData.snowflakes || 0) < 50;
    
    // Update preview status (read-only, shows ownership)
    updatePreviewStatus('santaHat', 'santaHatPreview');
    updatePreviewStatus('elfHat', 'elfHatPreview');
    updatePreviewStatus('antlers', 'antlersPreview');
    updatePreviewStatus('carrotNose', 'carrotPreview');
    
    // Update outfit tab equip buttons
    updateCosmeticUI('santaHat', 'toggleSantaHat', 'santaHatStatus', 'üéÖ Santa Hat');
    updateCosmeticUI('elfHat', 'toggleElfHat', 'elfHatStatus', 'üßù Elf Hat');
    updateCosmeticUI('antlers', 'toggleAntlers', 'antlersStatus', 'ü¶å Antlers');
    updateCosmeticUI('carrotNose', 'toggleCarrot', 'carrotStatus', '‚õÑ Carrot Nose');
    updateCosmeticUI('crown', 'toggleCrown', 'crownStatus', 'üëë Royal Crown');

// Update crown buy button
const crownBuyBtn = document.getElementById('buyCrown');
if (crownBuyBtn) {
    if (saveData.cosmetics.crown.owned) {
        crownBuyBtn.style.display = 'none';
    } else {
        crownBuyBtn.style.display = 'block';
        crownBuyBtn.disabled = saveData.coins < 1000;
    }
}
}

function updatePreviewStatus(cosmeticKey, elementId) {
    const elem = document.getElementById(elementId);
    if (!elem) return;
    
    const cosmetic = saveData.cosmetics[cosmeticKey];
    if (cosmetic.owned) {
        elem.textContent = 'Owned ‚úì';
        elem.className = 'text-[8px] text-green-400 mt-1';
    } else {
        elem.textContent = 'Locked';
        elem.className = 'text-[8px] text-gray-400 mt-1';
    }
}
function updateCosmeticUI(cosmeticKey, buttonId, statusId, name) {
    const cosmetic = saveData.cosmetics[cosmeticKey];
    const button = document.getElementById(buttonId);
    const status = document.getElementById(statusId);
    
    if (!cosmetic.owned) {
        status.textContent = 'Locked';
        status.className = 'text-[10px] text-red-400';
        button.textContent = 'LOCKED';
        button.disabled = true;
        button.className = 'game-btn px-3 py-2 text-xs w-full';
    } else if (cosmetic.equipped) {
        status.textContent = 'Equipped ‚úì';
        status.className = 'text-[10px] text-green-400';
        button.textContent = 'UNEQUIP';
        button.disabled = false;
        button.className = 'game-btn px-3 py-2 text-xs w-full bg-red-500 border-red-700 text-white';
    } else {
        status.textContent = 'Owned';
        status.className = 'text-[10px] text-blue-400';
        button.textContent = 'EQUIP';
        button.disabled = false;
        button.className = 'game-btn px-3 py-2 text-xs w-full bg-green-500 border-green-700 text-white';
    }
}

function toggleCosmetic(cosmeticKey) {
    if (!saveData.cosmetics[cosmeticKey].owned) return;
    
    // Define categories
    const hats = ['crown', 'santaHat', 'elfHat', 'antlers'];
    const accessories = ['carrotNose'];
    // If equipping, unequip others in same category
    if (!saveData.cosmetics[cosmeticKey].equipped) {
        if (hats.includes(cosmeticKey)) {
            // Unequip all other hats
            hats.forEach(hat => {
                if (hat !== cosmeticKey) saveData.cosmetics[hat].equipped = false;
            });
        }
        if (accessories.includes(cosmeticKey)) {
            // Unequip all other accessories
            accessories.forEach(acc => {
                if (acc !== cosmeticKey) saveData.cosmetics[acc].equipped = false;
            });
        }
    }
    
    // Toggle the clicked cosmetic
    saveData.cosmetics[cosmeticKey].equipped = !saveData.cosmetics[cosmeticKey].equipped;
    saveDataToStorage();
    updateChristmasUI();
    updateShopUI();
}

// Present opening queue system
let presentQueue = [];
let isProcessingPresent = false;

function openPresent(tier) {
    let cost, rewards;
    
    if (tier === 'basic') {
        cost = 10;
        rewards = [
            { type: 'coins', amount: 50, chance: 40, text: '50 Coins!' },
            { type: 'coins', amount: 100, chance: 30, text: '100 Coins!' },
            { type: 'coins', amount: 200, chance: 20, text: '200 Coins! üéâ' },
            { type: 'cosmetic', item: 'carrotNose', chance: 10, text: '‚õÑ Carrot Nose Unlocked!' }
        ];
    } else if (tier === 'premium') {
        cost = 25;
        rewards = [
            { type: 'coins', amount: 150, chance: 30, text: '150 Coins!' },
            { type: 'coins', amount: 300, chance: 25, text: '300 Coins!' },
            { type: 'coins', amount: 500, chance: 20, text: '500 Coins! üí∞' },
            { type: 'cosmetic', item: 'elfHat', chance: 15, text: 'üßù Elf Hat Unlocked!' },
            { type: 'cosmetic', item: 'antlers', chance: 10, text: 'ü¶å Antlers Unlocked!' }
        ];
    } else if (tier === 'legendary') {
        cost = 50;
        rewards = [
            { type: 'coins', amount: 500, chance: 25, text: '500 Coins!' },
            { type: 'coins', amount: 1000, chance: 20, text: '1000 Coins! ü§ë' },
            { type: 'coins', amount: 2000, chance: 15, text: '2000 Coins! üíé' },
            { type: 'cosmetic', item: 'santaHat', chance: 25, text: 'üéÖ SANTA HAT UNLOCKED!' },
            { type: 'cosmetic', item: 'elfHat', chance: 10, text: 'üßù Elf Hat Unlocked!' },
            { type: 'cosmetic', item: 'antlers', chance: 5, text: 'ü¶å Antlers Unlocked!' }
        ];
    }
    
    if ((saveData.snowflakes || 0) < cost) return;
    
    // Add to queue
    presentQueue.push({ cost, rewards });
    
    // Start processing if not already
    if (!isProcessingPresent) {
        processNextPresent();
    }
}

function processNextPresent() {
    if (presentQueue.length === 0) {
        isProcessingPresent = false;
        return;
    }
    
    isProcessingPresent = true;
    const present = presentQueue.shift();
    
    // Deduct cost
    saveData.snowflakes -= present.cost;
    
    // Roll for reward
    const roll = Math.random() * 100;
    let cumulative = 0;
    let selectedReward = null;
    
    for (const reward of present.rewards) {
        cumulative += reward.chance;
        if (roll < cumulative) {
            selectedReward = reward;
            break;
        }
    }
    
    if (!selectedReward) selectedReward = present.rewards[0];
    
    // Apply reward
    if (selectedReward.type === 'coins') {
        saveData.coins += selectedReward.amount;
    } else if (selectedReward.type === 'cosmetic') {
        if (!saveData.cosmetics[selectedReward.item].owned) {
            saveData.cosmetics[selectedReward.item].owned = true;
        } else {
            // Already owned - give coins instead
            saveData.coins += 100;
            selectedReward.text = '100 Bonus Coins! (Duplicate)';
        }
    }
    
    saveDataToStorage();
    updateChristmasUI();
    
    // Show reward with animation
    const rewardEl = document.getElementById('presentReward');
    const rewardText = document.getElementById('rewardText');
    rewardText.textContent = 'üéÅ ' + selectedReward.text;
    rewardEl.classList.remove('hidden');
    rewardEl.style.animation = 'none';
    setTimeout(() => {
        rewardEl.style.animation = 'bounce 0.5s';
    }, 10);
    
    // Process next present after delay
    setTimeout(() => {
        rewardEl.classList.add('hidden');
        processNextPresent();
    }, 2000);
}

function updatePerksUI() {
    const knightBtn = document.getElementById('btnKnightPerk');
    const knightStatus = document.getElementById('knightPerkStatus');
    
    if (saveData.perks.knightBladestorm) {
        knightBtn.textContent = 'OWNED';
        knightBtn.disabled = true;
        knightStatus.textContent = 'Status: Unlocked ‚úì';
        knightStatus.className = 'text-[10px] text-green-400 mt-2';
    } else {
        knightBtn.disabled = saveData.coins < 3500;
    }
    
    const archerBtn = document.getElementById('btnArcherPerk');
    const archerStatus = document.getElementById('archerPerkStatus');
    
    if (saveData.perks.archerRicochet) {
        archerBtn.textContent = 'OWNED';
        archerBtn.disabled = true;
        archerStatus.textContent = 'Status: Unlocked ‚úì';
        archerStatus.className = 'text-[10px] text-green-400 mt-2';
    } else {
        archerBtn.disabled = saveData.coins < 3500;
    }
}

function buyPerk(perkName) {
    if (perkName === 'knightBladestorm') {
        if (saveData.coins >= 2500 && !saveData.perks.knightBladestorm) {
            saveData.coins -= 2500;
            saveData.perks.knightBladestorm = true;
            saveDataToStorage();
            updatePerksUI();
        }
    }
    if (perkName === 'archerRicochet') {
        if (saveData.coins >= 2500 && !saveData.perks.archerRicochet) {
            saveData.coins -= 2500;
            saveData.perks.archerRicochet = true;
            saveDataToStorage();
            updatePerksUI();
        }
    }
}

// =====================================================
// UPGRADE SYSTEM FUNCTIONS
// =====================================================
function showUpgradeChoices() {
    isGameOver = true; // Pause game
    
    // Get 3 UNIQUE random upgrades
    const choices = [];
    const usedIds = new Set();
    // Filter only in-rotation upgrades
const availablePool = UPGRADE_POOL.filter(up => up.inRotation !== false);
    
    for (let i = 0; i < 3; i++) {
        const available = availablePool.filter(up => {
            const propName = up.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
            const currentStacks = player.upgrades[propName] || 0;
            return currentStacks < up.maxStack && !usedIds.has(up.id);
        });
        
        if (available.length > 0) {
            const selected = available[Math.floor(Math.random() * available.length)];
            choices.push(selected);
            usedIds.add(selected.id);
        } else {
            // If not enough unique upgrades, allow duplicates but still try to avoid
const fallback = availablePool.filter(up => !usedIds.has(up.id));
            if (fallback.length > 0) {
                const selected = fallback[Math.floor(Math.random() * fallback.length)];
                choices.push(selected);
                usedIds.add(selected.id);
            }
        }
    }
    
    // Generate upgraded UI cards
    const container = document.getElementById('upgradeChoices');
    container.innerHTML = '';
    
    choices.forEach((upgrade, index) => {
        const propName = upgrade.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
        const currentStacks = player.upgrades[propName] || 0;
        
        // Color coding by type
        let borderColor = 'border-gray-600';
        let glowColor = 'hover:border-yellow-400';
        if (upgrade.type === 'offense') {
            borderColor = 'border-red-600';
            glowColor = 'hover:border-red-400 hover:shadow-red-500/50';
        } else if (upgrade.type === 'defense') {
            borderColor = 'border-blue-600';
            glowColor = 'hover:border-blue-400 hover:shadow-blue-500/50';
        } else if (upgrade.type === 'utility') {
            borderColor = 'border-purple-600';
            glowColor = 'hover:border-purple-400 hover:shadow-purple-500/50';
        }
        
        const card = document.createElement('div');
        card.className = `bg-gradient-to-br from-gray-800 to-gray-900 p-6 rounded-lg border-4 ${borderColor} ${glowColor} cursor-pointer transform hover:scale-105 transition-all shadow-lg hover:shadow-2xl`;
        card.innerHTML = `
            <div class="text-6xl text-center mb-4 animate-bounce">${upgrade.icon}</div>
            <h3 class="text-xl text-yellow-300 text-center mb-2 font-bold tracking-wider">${upgrade.name}</h3>
            <p class="text-xs text-gray-300 text-center mb-4 leading-relaxed">${upgrade.description}</p>
            <div class="text-center mb-2">
                <span class="text-xs text-cyan-400 bg-cyan-900/30 px-3 py-1 rounded-full">Level ${currentStacks} ‚Üí ${currentStacks + 1}</span>
            </div>
            <div class="text-center">
                <span class="text-[10px] text-gray-500 uppercase">${upgrade.type}</span>
            </div>
        `;
        
        card.addEventListener('click', () => selectUpgrade(upgrade));
        container.appendChild(card);
    });
    
    document.getElementById('upgradeScreen').classList.remove('hidden');
}

function selectUpgrade(upgrade) {
    console.log('Upgrade selected:', upgrade.name);
    
    // Apply upgrade effect
    try {
        upgrade.effect(player);
    } catch (e) {
        console.error('Upgrade effect error:', e);
    }
    
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgradeScreen');
    upgradeScreen.classList.add('hidden');
    
    // Get stack count
    const propName = upgrade.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
    const stacks = player.upgrades[propName] || 1;
    
    // Visual feedback
    floatingTexts.push(new FloatingText(
        canvas.width / 2, 
        canvas.height / 2, 
        `+${upgrade.name}! (Lvl ${stacks})`, 
        '#fbbf24', 
        20
    ));
    
    // Show level up message temporarily
    const levelUpMsg = document.getElementById('levelUpMsg');
    const upgradeText = document.getElementById('upgradeText');
    levelUpMsg.classList.remove('hidden');
    upgradeText.textContent = `${upgrade.icon} ${upgrade.name} upgraded!`;
    setTimeout(() => levelUpMsg.classList.add('hidden'), 2000);
    
    // CRITICAL: Resume game state
    isGameOver = false;
    
    // Force update UI
    if (player) {
        player.updateUI();
    }
    updateAbilitySidebar();
    
    console.log('Game resumed, isGameOver:', isGameOver);

}

          function hitEnemy(enemy, dmg) {
    // CRITICAL HIT SYSTEM (Ninja cannot crit)
    let finalDamage = dmg;

    // Stun Gun logic
    if (player && player.upgrades.stunGun > 0) {
        const stunChance = player.upgrades.stunGun * 0.08; // 8% per stack
        if (Math.random() < stunChance && !enemy.isStunned) {
            enemy.isStunned = true;
            enemy.stunTimer = 120; // 2 seconds
            enemy.originalSpeed = enemy.speed;
            enemy.speed = 0; // Can't move
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, '‚ö° STUNNED!', '#fbbf24', 14));
            effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 40, 'rgba(251, 191, 36, 0.8)', 'explosion'));
        }
    }
    let canCrit = !player || player.type !== 'ninja'; // Ninja has 0% crit chance
    let isCrit = canCrit && Math.random() < 0.04; // 4% crit chance for others
    
    if (isCrit) {
        finalDamage *= 2;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'CRIT!', '#ff0', 16));
        effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 30, 'rgba(255,215,0,A)', 'explosion'));
    }

    // Elite enemy special mechanics
    if (enemy.isElite) {
        // Specter phases through attacks
        if (enemy.type === 'elite_specter' && enemy.isPhasing) {
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'PHASED!', '#9333ea', 12));
            return; // No damage during phase
        }
        
        // Tank shield blocks 75% damage
        if (enemy.type === 'elite_tank' && enemy.isShielded) {
            finalDamage *= 0.25;
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'BLOCKED!', '#60a5fa', 12));
            effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 25, 'rgba(96, 165, 250, A)', 'explosion'));
        }
    }
    
    const dead = enemy.takeDamage(finalDamage);

// Lifesteal healing - MEGA BUFFED & VISUAL
if (player && player.upgrades.lifesteal > 0) {
    if (!player.damageDealt) player.damageDealt = 0;
    player.damageDealt += finalDamage;
    const threshold = 25; // BUFFED: Heal every 15 damage (was 25)
    
    if (player.damageDealt >= threshold) {
        const healAmount = Math.floor(player.damageDealt / threshold) * (player.upgrades.lifesteal * 2); // BUFFED: 2 HP per stack (was 1)
        player.hp = Math.min(player.hp + healAmount, player.maxHp);
        player.damageDealt = player.damageDealt % threshold;
        
        // MEGA VISUAL FEEDBACK
        floatingTexts.push(new FloatingText(player.x, player.y - 20, `+${healAmount} HP ‚ù§Ô∏è`, '#ec4899', 18));
        
        // Big pink healing explosion
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 50, 'rgba(236, 72, 153, 0.8)', 'explosion'));
        
        // Healing particles rising up
        for (let i = 0; i < 5; i++) {
            effects.push({
                x: player.x + player.w/2 + (Math.random() - 0.5) * 30,
                y: player.y + player.h/2,
                vy: -2 - Math.random() * 2,
                life: 30,
                lifeMax: 30,
                size: 3 + Math.random() * 3,
                type: 'heal_particle',
                update: function() {
                    this.life--;
                    this.y += this.vy;
                    this.vy *= 0.95;
                },
                draw: function() {
                    if (this.life <= 0) return;
                    const alpha = this.life / this.lifeMax;
                    ctx.fillStyle = `rgba(236, 72, 153, ${alpha})`;
                    ctx.shadowColor = '#ec4899';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Pulsing red outline on player
        effects.push({
            x: player.x + player.w/2,
            y: player.y + player.h/2,
            radius: player.w / 2 + 5,
            life: 15,
            lifeMax: 15,
            type: 'heal_pulse',
            update: function() {
                this.life--;
                this.radius += 2;
            },
            draw: function() {
                if (this.life <= 0) return;
                const alpha = this.life / this.lifeMax;
                ctx.strokeStyle = `rgba(236, 72, 153, ${alpha * 0.8})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ec4899';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        });
        
        player.updateUI();
    }
}

    // Gold Leech upgrade
if (player && player.upgrades.goldLeech > 0) {
    const leechChance = player.upgrades.goldLeech * 0.1;
    if (Math.random() < leechChance) {
        saveData.pac.coins += 1;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+1 PAC', '#a855f7', 10));
    }
}
                if (dead) {
                   const idx = enemies.indexOf(enemy);
                    if (idx > -1) {
                        
                    // ELITE SPLITTER - Splits into smaller enemies on death
                    if (enemy.type === 'elite_splitter' && enemy.splitCount > 0) {
                        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'SPLIT!', '#22c55e', 14));
                        effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 60, 'rgba(34, 197, 94, A)', 'explosion'));
                        
                        for (let i = 0; i < enemy.splitCount; i++) {
                            const angle = (Math.PI * 2 / enemy.splitCount) * i;
                            const spawnDist = 40;
                            const spawnX = enemy.x + enemy.w/2 + Math.cos(angle) * spawnDist;
                            const spawnY = enemy.y + enemy.h/2 + Math.sin(angle) * spawnDist;
                            
                            const mini = new Enemy(spawnX, spawnY, 'normal', difficultyMultiplier * 0.6);
                            mini.w = 18;
                            mini.h = 18;
                            mini.color = '#22c55e';
                            enemies.push(mini);
                        }
                    }
                    
                    // BOSS DEATH
if (enemy.isBoss) {
    currentBoss = null;
    floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2, 'BOSS DEFEATED!', '#ffd700', 30));
    
    // INCREASED: 10 coins worth 3 each (1.2x increase from 8)
    for(let i = 0; i < 10; i++) {
        const spreadX = enemy.x + enemy.w/2 + (Math.random() - 0.5) * 100;
        const spreadY = enemy.y + enemy.h/2 + (Math.random() - 0.5) * 100;
        drops.push(new DropItem(spreadX, spreadY, 'coin', 3));
    }
}
                       drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'xp', enemy.xpValue));

// SPECIAL DROPS - Roll once for everything
const dropRoll = Math.random() * 100;

if (dropRoll < 3) {
    // 3% chance = Golden Coin
    const goldCoin = new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'goldcoin', 8);
    goldCoin.decayTimer = 240;
    drops.push(goldCoin);
    floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'üí∞ GOLD!', '#ffd700', 14));
}
else if (dropRoll < 6 && player.hp < player.maxHp * 0.8) {
    // 3% chance = Health Pack
    const healthPack = new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'health', 30);
    healthPack.decayTimer = 240;
    drops.push(healthPack);
    floatingTexts.push(new FloatingText(enemy.x, enemy.y, '‚ù§Ô∏è HEAL!', '#ef4444', 14));
}
else {
// Normal coins with luck bonus
let coinChance = 0.2 + (wave * 0.02);
if (player && player.upgrades.luck > 0) {
    coinChance += player.upgrades.luck * 0.05;
}
if (Math.random() < coinChance) {
    let coinValue = Math.ceil(wave / 2);
    // Luck can increase coin value
    if (player && player.upgrades.luck > 0 && Math.random() < 0.2) {
        coinValue += player.upgrades.luck;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'LUCKY!', '#4ade80', 12));
    }
    drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'coin', coinValue));
}
}

// CHRISTMAS SNOWFLAKE DROPS (if Christmas mode enabled)
if (saveData.christmasMode && Math.random() < 0.15) {
    drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'snowflake', 1));
}
                        if (enemy.type === 'frosty') {
                            effects.push(new Effect(enemy.x+enemy.w/2, enemy.y+enemy.h/2, 80, 'rgba(0,255,255,A)', 'ice_field'));
                        }
                        enemies.splice(idx, 1);
                        kills++;

                        // Lightning Step - Speed boost after kill
if (player && player.upgrades.speedBoost > 0) {
    player.speedBoostTimer = 60; // 1 second of speed boost
    floatingTexts.push(new FloatingText(player.x, player.y, '‚ö° SPEED!', '#fbbf24', 12));
}
                        // ‚úÖ Tempest fury bar charging
if (player && player.type === 'tempest') {
    player.furyKills = Math.min(player.furyKills + 1, player.furyBarMax);
    player.updateUI();
}
                    }
                }
          }
function showScreen(screenName) {
    Object.values(screens).forEach(s => s.classList.add('hidden'));
    gameUI.classList.add('hidden');
    
    gameTitle.classList.remove('hidden');
    coinDisplayMenu.classList.remove('hidden');
    document.getElementById('pacDisplayMenu').classList.remove('hidden');
    
    
       if (screenName === 'game') {
    gameTitle.classList.add('hidden');
    coinDisplayMenu.classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    document.getElementById('codeRedemptionBox').classList.add('hidden');
    gameUI.classList.remove('hidden');
    screens.game.classList.remove('hidden');
    } else if (screenName === 'pac') {
        gameTitle.classList.add('hidden');
        coinDisplayMenu.classList.add('hidden');
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        document.getElementById('pacRankScreen').classList.remove('hidden');
    } else if (screenName === 'menu') {
    document.getElementById('codeRedemptionBox').classList.remove('hidden');
    screens.menu.classList.remove('hidden');
    } else if (screenName === 'shop') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.shop.classList.remove('hidden');
    } else if (screenName === 'stats') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.stats.classList.remove('hidden');
   } else if (screenName === 'settings') {
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    document.getElementById('btnBackFromSettings').style.display = 'block';
    screens.settings.classList.remove('hidden');
} else if (screenName === 'menu') {
    // Ensure settings is hidden when returning to menu
    if (screens.settings && !screens.settings.classList.contains('hidden')) {
        screens.settings.classList.add('hidden');
    }
    screens.menu.classList.remove('hidden');
} else if (screenName === 'perks') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.perks.classList.remove('hidden');
    } else if (screenName === 'hero') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.hero.classList.remove('hidden');
   } else if (screenName === 'gameOver') {
    gameTitle.classList.add('hidden');
    coinDisplayMenu.classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    screens.gameOver.classList.remove('hidden');
} else if (screenName === 'christmas') {
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    screens.christmas.classList.remove('hidden');
    updateChristmasUI();
    createSnowfall();
} else if (screenName === 'multiplayer') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        if (!screens.multiplayer) {
            screens.multiplayer = document.getElementById('multiplayerScreen');
        }
        screens.multiplayer.classList.remove('hidden');
} else if (screenName === 'more') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        screens.more.classList.remove('hidden');
}
}

function updateAbilitySidebar() {
    if (!player) return;
    
    const sidebar = document.getElementById('abilitySidebar');
    if (!sidebar) return;
    
    sidebar.innerHTML = '';
    
    // Get all active upgrades
    const activeUpgrades = [];
    for (const [key, value] of Object.entries(player.upgrades)) {
        if (value > 0) {
            // Find the upgrade data
            const upgradeData = UPGRADE_POOL.find(up => {
                const propName = up.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
                return propName === key;
            });
            
            if (upgradeData) {
                activeUpgrades.push({
                    ...upgradeData,
                    stacks: value
                });
            }
        }
    }
    
    // Sort by type (offense, defense, utility)
    activeUpgrades.sort((a, b) => {
        const order = { offense: 0, defense: 1, utility: 2 };
        return order[a.type] - order[b.type];
    });
    
    // Create cards for each upgrade
    activeUpgrades.forEach(upgrade => {
        const card = document.createElement('div');
        card.className = `ability-card ability-card-${upgrade.type}`;
        card.innerHTML = `
            <span class="ability-icon">${upgrade.icon}</span>
            <span class="ability-stack">√ó${upgrade.stacks}</span>
        `;
        card.title = `${upgrade.name} (Level ${upgrade.stacks})`;
        sidebar.appendChild(card);
    });
}

        

function updateStats() {
    // Display kills from save data (which now tracks correctly)
ui.statTotalKills.textContent = saveData.stats.kills || 0;
    ui.statTotalDeaths.textContent = saveData.stats.deaths;
    ui.statBestLevel.textContent = saveData.stats.bestLevel;
    ui.statBestWave.textContent = saveData.stats.bestWave;
    
    // Hero colors mapping
    const heroColors = {
        knight: '#2563eb',
        mage: '#dc2626',
        archer: '#16a34a',
        ninja: '#000000',
        tempest: '#d1d5db',
        zap: '#fbbf24'
    };
    
    const heroNames = {
        knight: 'Knight',
        mage: 'Mage',
        archer: 'Archer',
        ninja: 'Ninja',
        tempest: 'Tempest',
        zap: 'Zap'
    };
    
    // Get top 3 heroes by kills
    const heroKills = saveData.stats.heroKills || { knight: 0, mage: 0, archer: 0, ninja: 0, tempest: 0, zap: 0 };
    const sortedHeroes = Object.entries(heroKills)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3);
    
    // Update 1st place
    if (sortedHeroes[0]) {
        const [hero, kills] = sortedHeroes[0];
        document.getElementById('hero1stBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero1stName').textContent = heroNames[hero];
        document.getElementById('hero1stKills').textContent = kills + ' kills';
    }
    
    // Update 2nd place
    if (sortedHeroes[1]) {
        const [hero, kills] = sortedHeroes[1];
        document.getElementById('hero2ndBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero2ndName').textContent = heroNames[hero];
        document.getElementById('hero2ndKills').textContent = kills + ' kills';
    } else {
        document.getElementById('hero2ndBlock').style.backgroundColor = '#4b5563';
        document.getElementById('hero2ndName').textContent = '---';
        document.getElementById('hero2ndKills').textContent = '0';
    }
    
    // Update 3rd place
    if (sortedHeroes[2]) {
        const [hero, kills] = sortedHeroes[2];
        document.getElementById('hero3rdBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero3rdName').textContent = heroNames[hero];
        document.getElementById('hero3rdKills').textContent = kills + ' kills';
    } else {
        document.getElementById('hero3rdBlock').style.backgroundColor = '#4b5563';
        document.getElementById('hero3rdName').textContent = '---';
        document.getElementById('hero3rdKills').textContent = '0';
    }
}

function startGame(type) {
    showScreen('game');
    
    // Pick random map
    const mapNames = Object.keys(GAME_CONFIG.MAPS);
    const randomMap = mapNames[Math.floor(Math.random() * mapNames.length)];
    currentMap = randomMap;
    
    // Generate map objects
    generateMapObjects(randomMap);
    
    // Show map name
    const mapData = GAME_CONFIG.MAPS[randomMap];
    floatingTexts.push(new FloatingText(canvas.width/2 - 100, 100, `${mapData.name}`, '#fbbf24', 24));
    
    player = new Player(canvas.width/2, canvas.height/2, type);
    enemies = [];
    projectiles = [];
    effects = [];
    drops = [];
    turrets = [];
    floatingTexts = [];
    keys = {};
    kills = 0;
    sessionCoins = 0;
    frameCount = 0;
    
    // Load Inventory
    sessionTurrets = saveData.inventory.turrets || 0;
    ui.hudTurretCount.textContent = sessionTurrets;
    if(sessionTurrets > 0) ui.turretHud.classList.remove('hidden');
    else ui.turretHud.classList.add('hidden');
    sessionBombs = saveData.inventory.bombs || 0;
    ui.hudBombCount.textContent = sessionBombs;
    if(sessionBombs > 0) ui.bombHud.classList.remove('hidden');
    else ui.bombHud.classList.add('hidden');

    // Wave Reset
    wave = 1;
    waveTimer = GAME_CONFIG.WAVES.DURATION * 60; 
    enemySpawnTimer = 0;
    difficultyMultiplier = 1;
    bossActive = false;
    currentBoss = null;
    bossWaveCount = 0;
    
    isGameOver = false;
    
    player.updateUI();
    ui.kills.textContent = 0;
    updateAbilitySidebar();
    ui.gameCoins.textContent = 0;
    ui.wave.textContent = 1;
    
    // FIX: Reset wave message text properly
    document.getElementById('waveMsgText').textContent = 'WAVE 1';
    document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    ui.waveMsg.classList.remove('hidden');
    setTimeout(() => ui.waveMsg.classList.add('hidden'), 2000);

    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoop();
}

            
function gameLoop() {
    gameLoopId = requestAnimationFrame(gameLoop);
    if (isGameOver) {
        // Still render the game but don't update game state
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw background
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
        
        // Draw everything frozen in place
        effects.forEach(e => e.draw());
        turrets.forEach(t => t.draw());
        projectiles.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        if (player) player.draw();
        drops.forEach(d => d.draw());
        floatingTexts.forEach(ft => ft.draw());
        
        return; // Don't update, just render
    }
// Draw map background
if (currentMap) {
    const mapData = GAME_CONFIG.MAPS[currentMap];
    ctx.fillStyle = mapData.bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Background grid
    if (frameCount % 2 === 0) {
        ctx.strokeStyle = mapData.gridColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
    }
    
    // Draw map objects
    mapObjects.forEach(obj => obj.draw());
} else {
    // Fallback
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (frameCount % 2 === 0) {
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
    }
}
                // --- WAVE LOGIC ---
                frameCount++;
                waveTimer--;
                
                if (frameCount % 30 === 0) { 
                    ui.waveTimer.textContent = `Next: ${Math.ceil(waveTimer/60)}s`;
                }

                if (waveTimer <= 0) {
    wave++;
    waveTimer = GAME_CONFIG.WAVES.DURATION * 60; 
    // SMOOTH SCALING: Gradual difficulty increase
    const rawMultiplier = 1 + (wave * GAME_CONFIG.WAVES.HP_SCALING);
    difficultyMultiplier = Math.min(rawMultiplier, GAME_CONFIG.WAVES.HP_SCALING_CAP);
    
    // BONUS: Slightly increase enemy speed every 5 waves (subtle)
    if (wave % 5 === 0 && wave > 1) {
        Object.keys(GAME_CONFIG.ENEMIES).forEach(key => {
            if (GAME_CONFIG.ENEMIES[key].speed) {
                GAME_CONFIG.ENEMIES[key].speed *= 1.03; // 3% speed boost per 5 waves
            }
        });
    }
    
    ui.wave.textContent = wave;
    // CHECK IF BOSS WAVE
    if (wave % 5 === 0) {
        bossActive = true;
        bossWaveCount++;
        document.getElementById('waveMsgText').textContent = '‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è';
        document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-purple-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    } else {
        document.getElementById('waveMsgText').textContent = 'WAVE ' + wave;
        document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    }
    
    ui.waveMsg.classList.remove('hidden');
    setTimeout(() => ui.waveMsg.classList.add('hidden'), 3000);
}
                // --- SPAWNING LOGIC ---
                enemySpawnTimer--;
                if (enemySpawnTimer <= 0) {
                    // SPAWN BOSS IF IT'S BOSS WAVE
                    if (bossActive && !currentBoss) {
                        const bossX = canvas.width / 2 - 50;
                        const bossY = -120;
                        currentBoss = new Enemy(bossX, bossY, 'boss', 1 + (bossWaveCount * 0.5));
                        currentBoss.isBoss = true;
                        enemies.push(currentBoss);
                        bossActive = false;
                    }
                    
                   // NORMAL ENEMY SPAWNS (don't spawn during boss wave)
if (wave % 5 !== 0) {
    const rand = Math.random();
    let type = 'normal';

    // Map-based spawn bonuses (20% increased chance for map-specific enemies)
    const mapBonus = 0.16;
    let mapRoll = Math.random();
    
    if (currentMap === 'desert' && mapRoll < mapBonus && wave >= 1) {
        type = 'ranger'; // Cactus map = more rangers
    }
    else if (currentMap === 'volcano' && mapRoll < mapBonus && wave >= 3) {
        type = 'brute'; // Volcano = more brutes
    }
    else if (currentMap === 'ice' && mapRoll < mapBonus && wave >= 5) {
        type = 'frosty'; // Ice = more frosties
    }
    else if (currentMap === 'forest' && mapRoll < mapBonus && wave >= 6) {
        type = Math.random() < 0.5 ? 'elite_splitter' : 'elite_tank'; // Forest = more splitters/tanks
    }
    else if (currentMap === 'swamp' && mapRoll < mapBonus && wave >= 7) {
        type = 'elite_specter'; // Swamp = more specters
    }
    else {

    // FIXED SPAWN LOGIC - Check spawn waves and roll separately
    // Ranger spawning (from wave 1)
    if (rand < 0.20) {
        type = 'ranger';
    }
    // Elite enemies (check wave requirement first)
    else if (wave >= GAME_CONFIG.ENEMIES.elite_specter.spawn_wave && rand >= 0.20 && rand < 0.28) {
        type = 'elite_specter';
    }
    else if (wave >= GAME_CONFIG.ENEMIES.elite_tank.spawn_wave && rand >= 0.28 && rand < 0.40) {
        type = 'elite_tank';
    }
    else if (wave >= GAME_CONFIG.ENEMIES.elite_splitter.spawn_wave && rand >= 0.40 && rand < 0.52) {
        type = 'elite_splitter';
    }
    // Brute (from wave 3)
    else if (wave >= GAME_CONFIG.ENEMIES.brute.spawn_wave && rand >= 0.52 && rand < 0.67) {
        type = 'brute';
    }
    // Frosty (from wave 5)
    else if (wave >= GAME_CONFIG.ENEMIES.frosty.spawn_wave && rand >= 0.67 && rand < 0.85) {
        type = 'frosty';
    }
    // Normal enemy (fallback)
    else {
        type = 'normal';
    }
    }
                        let ex, ey;
                        if (Math.random() < 0.5) {
                            ex = Math.random() < 0.5 ? -40 : canvas.width + 40;
                            ey = Math.random() * canvas.height;
                        } else {
                            ex = Math.random() * canvas.width;
                            ey = Math.random() < 0.5 ? -40 : canvas.height + 40;
                        }
                        enemies.push(new Enemy(ex, ey, type, difficultyMultiplier));
                    }
                    
                    // REDUCED spawn rate - enemies spawn SLOWER
                    let spawnRate = Math.max(20, 200 * Math.pow(0.92, wave - 1));
                    enemySpawnTimer = spawnRate;
                }
                // --- UPDATES ---
                effects.forEach((e, i) => {
                    e.update(); e.draw();
                    if (e.life <= 0) effects.splice(i, 1);
                });

               for (let i = drops.length - 1; i >= 0; i--) {
    const collected = drops[i].update();
    drops[i].draw();
    if (collected) drops.splice(i, 1);
}

                turrets.forEach((t, i) => {
                    t.update(); t.draw();
                    if(t.life <= 0) turrets.splice(i, 1);
                });

                player.update();

                player.update();
                
                // Draw opponent player in multiplayer
                if (isMultiplayer && opponentPlayer) {
                    drawOpponent();
                }
                
        
                
              // FIXED: Use reverse loop to prevent array mutation issues
for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    const shouldRemove = p.update(); // Boomerangs can request removal
    
    // Remove boomerangs that expired
    if (shouldRemove) {
        projectiles.splice(i, 1);
        continue;
    }
    
    // Remove projectiles that go off screen
    if (p.x < -50 || p.x > canvas.width+50 || p.y < -50 || p.y > canvas.height+50) {
        projectiles.splice(i, 1);
        continue;
    }

    // Check if enemy projectile hits player
if (p.isEnemyProjectile && player && rectCollision(p, player)) {
    // Knight shield deflection
    if (player.type === 'knight' && player.shieldMode) {
        // Check if projectile is coming from the front
        const angleToProjectile = Math.atan2(p.y - player.y, p.x - player.x);
        let angleDiff = Math.abs(angleToProjectile - player.angle);
        if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
        
        // Deflect if within 90 degrees of where shield is facing
        if (angleDiff < Math.PI/2) {
            floatingTexts.push(new FloatingText(player.x, player.y, 'BLOCKED!', '#3b82f6', 14));
            effects.push(new Effect(p.x, p.y, 25, 'rgba(59, 130, 246, 0.8)', 'explosion'));
            projectiles.splice(i, 1);
            continue;
        }
    }
    
    if (!player.isDashing) {
        let damage = p.damage;
        
        // Take damage normally
        player.hp -= damage;
floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
        player.updateUI();
        floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 25, 'rgba(255, 0, 0, 0.6)', 'explosion'));
        
        if (player.hp <= 0) {
            endGame();
        }
    }
    projectiles.splice(i, 1);
    continue;
}
    
// Check collision with enemies (SKIP if enemy projectile)
let projectileHit = false;
let enemiesHitThisFrame = 0;

if (!p.isEnemyProjectile) {
    // Track which enemies this projectile already hit (for pierce)
    if (!p.hitEnemies) p.hitEnemies = new Set();
    
    for (let j = enemies.length - 1; j >= 0; j--) {
        // PIERCE FIX: Skip if already hit this enemy
        if (p.hitEnemies.has(enemies[j])) continue;
        
        if (rectCollision(p, enemies[j])) {
            // Mark this enemy as hit
            p.hitEnemies.add(enemies[j]);
            if (p.type === 'fireball') {
                // FIREBALL EXPLOSION - Hit ALL enemies in radius
                const explosionRadius = GAME_CONFIG.PROJECTILES.fireball.explosionRadius;
                effects.push(new Effect(p.x, p.y, explosionRadius, 'rgba(255, 140, 0, A)', 'explosion'));
                
                for (let k = enemies.length - 1; k >= 0; k--) {
                    const e = enemies[k];
                    const dist = Math.hypot((e.x+e.w/2)-p.x, (e.y+e.h/2)-p.y);
                    if (dist < explosionRadius) {
                        hitEnemy(e, p.damage);
                    }
                }
                projectileHit = true;
            } else {
                // Regular projectile hit
                if (p.knockback > 0) {
                    enemies[j].pushbackX += Math.cos(p.angle) * p.knockback;
                    enemies[j].pushbackY += Math.sin(p.angle) * p.knockback;
                }
                
                const damageToApply = p.currentDamage !== undefined ? p.currentDamage : p.damage;
              // Apply damage with pierce reduction if applicable
if (player && player.upgrades.piercingShots > 0 && enemiesHitThisFrame > 0) {
    const damageReduction = 0.8; // UPDATED: 80% damage per pierce (was 60%)
    const reducedDamage = damageToApply * Math.pow(damageReduction, enemiesHitThisFrame);
    hitEnemy(enemies[j], reducedDamage);
} else {
    hitEnemy(enemies[j], damageToApply);
}
                enemiesHitThisFrame++;
                
                // Explosive Shots upgrade
                if (player && player.upgrades.explosiveShots > 0) {
                    const explosionRadius = 40 * player.upgrades.explosiveShots;
                    effects.push(new Effect(enemies[j].x + enemies[j].w/2, enemies[j].y + enemies[j].h/2, 
                                           explosionRadius, 'rgba(255, 100, 0, 0.6)', 'explosion'));
                    
                    for (let k = enemies.length - 1; k >= 0; k--) {
                        if (k === j) continue;
                        const e = enemies[k];
                        const dist = Math.hypot((e.x + e.w/2) - (enemies[j].x + enemies[j].w/2),
                                               (e.y + e.h/2) - (enemies[j].y + enemies[j].h/2));
                        if (dist < explosionRadius) {
                            hitEnemy(e, damageToApply * 0.5);
                        }
                    }
                }
                
                // Split Shot upgrade
                if (player && player.upgrades.splitShot > 0 && (p.type === 'arrow' || p.type === 'turret')) {
                    for (let s = 0; s < player.upgrades.splitShot; s++) {
                        const spreadAngle = (Math.random() - 0.5) * Math.PI / 3;
                        const splitProj = new Projectile(
                            enemies[j].x + enemies[j].w/2,
                            enemies[j].y + enemies[j].h/2,
                            p.angle + spreadAngle,
                            p.type,
                            p.damage * 0.6
                        );
                        splitProj.w = p.w * 0.7;
                        splitProj.h = p.h * 0.7;
                        projectiles.push(splitProj);
                    }
                }
                
                // CHARGED LIGHTNING - Chain to nearby enemies
                if (p.type === 'lightning' && p.isCharged && !p.hasChained) {
                    p.hasChained = true;
                    const hitX = enemies[j].x + enemies[j].w/2;
                    const hitY = enemies[j].y + enemies[j].h/2;
                    const chainRange = 120;
                    
                    // Find up to 3 nearby enemies to chain to
                    let chainedEnemies = [];
                    for (let k = enemies.length - 1; k >= 0; k--) {
                        if (k === j) continue; // Skip the hit enemy
                        const e = enemies[k];
                        const dist = Math.hypot((e.x + e.w/2) - hitX, (e.y + e.h/2) - hitY);
                        
                        if (dist < chainRange) {
                            chainedEnemies.push({ enemy: e, dist: dist });
                        }
                    }
                    
                    // Sort by distance and take closest 3
                    chainedEnemies.sort((a, b) => a.dist - b.dist);
                    chainedEnemies = chainedEnemies.slice(0, 3);
                    
                    // Chain lightning to each
                    chainedEnemies.forEach(target => {
                        // Draw lightning arc
                        effects.push({
                            x: hitX,
                            y: hitY,
                            targetX: target.enemy.x + target.enemy.w/2,
                            targetY: target.enemy.y + target.enemy.h/2,
                            life: 8,
                            lifeMax: 8,
                            type: 'lightning_arc',
                            update: function() { this.life--; },
                            draw: function() {
                                if (this.life <= 0) return;
                                ctx.save();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 3;
                                ctx.shadowColor = '#fbbf24';
                                ctx.shadowBlur = 15;
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                // Jagged lightning path
                                const segments = 4;
                                for (let s = 1; s <= segments; s++) {
                                    const t = s / segments;
                                    const x = this.x + (this.targetX - this.x) * t + (Math.random() - 0.5) * 20;
                                    const y = this.y + (this.targetY - this.y) * t + (Math.random() - 0.5) * 20;
                                    ctx.lineTo(x, y);
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        });
                        
                        // Deal damage to chained enemy
                        hitEnemy(target.enemy, p.damage * 0.6); // 60% of main damage
                        floatingTexts.push(new FloatingText(target.enemy.x, target.enemy.y, '‚ö°', '#fbbf24', 14));
                    });
                    
                    if (chainedEnemies.length > 0) {
                        floatingTexts.push(new FloatingText(hitX, hitY - 20, `CHAIN x${chainedEnemies.length}!`, '#fff', 16));
                    }
                }
                
              // PIERCING MECHANIC - HEAVILY NERFED DAMAGE
if (player && player.upgrades.piercingShots > 0) {
    const maxPierces = player.upgrades.piercingShots + 1;
    
    // HEAVY NERF: Reduce damage by 50% for each enemy pierced
    const damageReduction = 0.5; // 50% damage after first hit (was 70%)
    const reducedDamage = damageToApply * Math.pow(damageReduction, enemiesHitThisFrame);
    hitEnemy(enemies[j], reducedDamage);
    
    if (enemiesHitThisFrame >= maxPierces) {
        projectileHit = true;
    }
    // Otherwise keep going through enemies!
} else if (p.pierce) {
                    // Ricochet arrows have their own pierce
                    if (enemiesHitThisFrame >= 3) {
                        projectileHit = true;
                    }
                } else {
                    projectileHit = true; // Normal projectiles stop on first hit
                }
            }
            break;
       }
    }
}
    
    // Remove projectile after it hits (unless piercing)
    if (projectileHit) {
        projectiles.splice(i, 1);
    }
}
                
enemies.forEach(e => {
    e.update();
    if (rectCollision(player, e)) {
        if (!player.isDashing) {
            // Check dodge chance
            if (player.upgrades.dodgeChance > 0) {
                const dodgeChance = player.upgrades.dodgeChance * 0.08;
                if (Math.random() < dodgeChance) {
                    floatingTexts.push(new FloatingText(player.x, player.y, 'DODGE!', '#00ffff', 14));
                    effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 30, 'rgba(0, 255, 255, 0.6)', 'explosion'));
                    return; // Skip damage entirely
                }
            }
            
            let damage = e.isBoss ? GAME_CONFIG.ENEMIES.boss.damage : 1;
            
// Take damage normally
player.hp -= damage;
floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
            player.updateUI();
            if (frameCount % 20 === 0) { 
               floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
            }

// Thorns upgrade (NERFED - only 15% reflection)
if (player.upgrades.thorns > 0) {
    const thornsDamage = damage * 0.15 * player.upgrades.thorns; // NERFED: Was 0.3, now 0.15
                e.hp -= thornsDamage;
                floatingTexts.push(new FloatingText(e.x, e.y, 'üåµ -' + Math.floor(thornsDamage), '#22c55e', 12));
                effects.push(new Effect(e.x + e.w/2, e.y + e.h/2, 25, 'rgba(34, 197, 94, 0.6)', 'explosion'));
                
                if (e.hp <= 0) {
                    const idx = enemies.indexOf(e);
                    if (idx > -1) {
                        enemies.splice(idx, 1);
                        kills++;
                    }
                }
            }
            
            if (player.hp <= 0) {
                endGame();
            }
        }
    }
});

// ADD THIS LINE TO UPDATE KILL COUNTER EVERY FRAME:
ui.kills.textContent = kills;
                
for (let i = floatingTexts.length - 1; i >= 0; i--) {
    if (floatingTexts[i]) {
        floatingTexts[i].update();
        floatingTexts[i].draw();
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }
}
}

            function endGame() {
    isGameOver = true;
    
    // CAP: Maximum 5000 coins per game to prevent exploits
    const cappedSessionCoins = Math.min(sessionCoins, 1000);
    
    // FIXED: Ensure all data is properly saved with explicit number conversion
    saveData.coins = parseInt(saveData.coins) + parseInt(cappedSessionCoins);
    // Use in-game kill counter (100% accurate)
saveData.stats.kills = parseInt(kills);
   // Track kills for current hero
if (!saveData.stats.heroKills) {
    saveData.stats.heroKills = { knight: 0, mage: 0, archer: 0, ninja: 0, tempest: 0, zap: 0 };
}
saveData.stats.heroKills[player.type] = (saveData.stats.heroKills[player.type] || 0) + parseInt(kills);
    saveData.stats.deaths = parseInt(saveData.stats.deaths) + 1;
saveData.stats.heroKills[player.type] = (saveData.stats.heroKills[player.type] || 0) + parseInt(kills);
    saveData.stats.deaths = parseInt(saveData.stats.deaths) + 1;
    
    // Calculate PAC coins (0 if wave 1) - CAP at 2000 PAC per game
    const timeAlive = frameCount / 60; // Convert frames to seconds
    const rawPAC = calculatePACCoins(wave, kills, timeAlive);
    const earnedPAC = Math.min(rawPAC, 800); // CAP: Max 2000 PAC per game
    if (earnedPAC > 0) {
        updatePACRank(earnedPAC);
    }
    saveData.inventory.turrets = parseInt(sessionTurrets);
    saveData.inventory.bombs = parseInt(sessionBombs);
    
    if (wave > saveData.stats.bestWave) saveData.stats.bestWave = parseInt(wave);
    if (player.level > saveData.stats.bestLevel) saveData.stats.bestLevel = parseInt(player.level);
    
    // Force immediate save
    saveDataToStorage();
    
    // Double-check save worked
    setTimeout(() => {
        const verification = localStorage.getItem(GAME_CONFIG.STORAGE_KEY);
        if (verification) {
            console.log('‚úÖ Save verified');
        } else {
            console.error('‚ùå Save failed - attempting recovery');
            saveDataToStorage();
        }
    }, 100);

    showScreen('gameOver');
    ui.finalKills.textContent = kills;
    // Update total kills display
ui.statTotalKills.textContent = saveData.stats.kills;
    ui.finalCoins.textContent = cappedSessionCoins + (sessionCoins > 5000 ? ' (CAPPED)' : '');
    ui.finalWave.textContent = wave;
    document.getElementById('finalPAC').textContent = earnedPAC + (rawPAC > 2000 ? ' (CAPPED)' : '');
}
            
           function rectCollision(r1, r2) {
    // Simple rectangle collision - no special hitboxes
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

            // --- SHOP LOGIC ---
            function buyUpgrade(type) {
                if (type === 'health') {
                    const cost = GAME_CONFIG.SHOP.HEALTH_BASE * (saveData.upgrades.health + 1);
                    if (saveData.coins >= cost && saveData.upgrades.health < 5) {
                        saveData.coins -= cost;
                        saveData.upgrades.health++;
                        saveDataToStorage();
                    }
                }
                if (type === 'magnet') {
                    const cost = GAME_CONFIG.SHOP.MAGNET_BASE * (saveData.upgrades.magnet + 1);
                    if (saveData.coins >= cost && saveData.upgrades.magnet < 5) {
                        saveData.coins -= cost;
                        saveData.upgrades.magnet++;
                        saveDataToStorage();
                    }
                }
                if (type === 'turret') {
                    if(saveData.coins >= GAME_CONFIG.TURRET.COST) {
                        saveData.coins -= GAME_CONFIG.TURRET.COST;
                        saveData.inventory.turrets++;
                        saveDataToStorage();
                    }
                }
                if (type === 'bomb') {
                    if(saveData.coins >= GAME_CONFIG.BOMB.COST) {
                        saveData.coins -= GAME_CONFIG.BOMB.COST;
                        saveData.inventory.bombs++;
                        saveDataToStorage();
                    }
                }
                if (type === 'skin') {
                    if (!saveData.upgrades.goldSkin && saveData.coins >= GAME_CONFIG.SHOP.SKIN) {
                        // Purchase skin
                        saveData.coins -= GAME_CONFIG.SHOP.SKIN;
                        saveData.upgrades.goldSkin = true;
                        saveData.upgrades.goldSkinEquipped = true;
                        saveDataToStorage();
                    } else if (saveData.upgrades.goldSkin) {
                        // Equip/unequip skin
                        saveData.upgrades.goldSkinEquipped = true;
                        saveDataToStorage();
                    }
                }

                if (type === 'obsidianSkin') {
    if (!saveData.upgrades.obsidianSkin && saveData.coins >= 1500) {
        // Purchase obsidian skin
        saveData.coins -= 1500;
        saveData.upgrades.obsidianSkin = true;
        saveData.upgrades.obsidianSkinEquipped = true;
        // Unequip other skins
        saveData.upgrades.goldSkinEquipped = false;
        saveDataToStorage();
    } else if (saveData.upgrades.obsidianSkin) {
        // Equip obsidian skin
        saveData.upgrades.obsidianSkinEquipped = true;
        // Unequip other skins
        saveData.upgrades.goldSkinEquipped = false;
        saveDataToStorage();
    }
}
if (type === 'crown') {
    if (saveData.coins >= 1000 && !saveData.cosmetics.crown.owned) {
        saveData.coins -= 1000;
        saveData.cosmetics.crown.owned = true;
        saveDataToStorage();
        updateChristmasUI();
    }
}
            }
            // --- CODE REDEMPTION SYSTEM ---
const REWARD_CODES = {
    'ELEPHANT12': { description: 'Code Expired' },
    'CREATOR': { coins: 100000, description: '+100,000 Coins! üéâ' },
    'NEWUPDATE2': { coins: 500, description: '+500 Coins!' },
    'IMSORRY': { description: 'Code Expired' },
    'CHRISTMAS25': { snowflakes: 10, description: '+10 Snowflakes! ‚ùÑÔ∏è' },
    'CREATORSNOW': { snowflakes: 3000, description: '+3000 Snowflakes! ‚ùÑÔ∏èüéÅ' },
    'CREATORPAC': { pac: 10000, description: '+10,000 PAC Points! üèÜ' },
    'UPGRADES': { snowflakes: 25, description: '+25 Snowflakes ‚ùÑÔ∏è' },
};

function redeemCode(code) {
    const upperCode = code.toUpperCase().trim();
    const msgEl = document.getElementById('codeMessage');
    
    // Check if code exists
    if (!REWARD_CODES[upperCode]) {
        msgEl.textContent = '‚ùå Invalid code';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    
    // Check if already redeemed
    if (saveData.redeemedCodes.includes(upperCode)) {
        msgEl.textContent = '‚ö†Ô∏è Already redeemed';
        msgEl.className = 'text-[10px] mt-2 text-center text-yellow-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    
    // SUCCESS! Give rewards
const reward = REWARD_CODES[upperCode];
if (reward.coins) saveData.coins += reward.coins;
if (reward.snowflakes) {
    if (!saveData.snowflakes) saveData.snowflakes = 0;
    saveData.snowflakes += reward.snowflakes;
}
if (reward.pac) {
    updatePACRank(reward.pac);
}
saveData.redeemedCodes.push(upperCode);
saveDataToStorage();
    
    msgEl.textContent = `‚úÖ ${reward.description}`;
    msgEl.className = 'text-[10px] mt-2 text-center text-green-400';
    msgEl.classList.remove('hidden');
    document.getElementById('codeInput').value = '';
    
    setTimeout(() => msgEl.classList.add('hidden'), 3000);
}

            // --- EVENT LISTENERS ---
            
            // --- EVENT LISTENERS ---

// Navigation Buttons
document.getElementById('btnPlay').addEventListener('click', () => showScreen('hero'));
document.getElementById('btnMore').addEventListener('click', () => showScreen('more'));
// PAC Rank Display Click
document.getElementById('pacDisplayMenu').addEventListener('click', () => {
    showScreen('pac');
    document.getElementById('gameTitle').classList.add('hidden');
    document.getElementById('coinDisplayMenu').classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
});
document.getElementById('btnStats').addEventListener('click', () => { 
    updateStats(); 
    showScreen('stats'); 
});
document.getElementById('btnShop').addEventListener('click', () => { 
    updateShopUI(); 
    showScreen('shop'); 
});
document.getElementById('btnBackFromMultiplayer').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnCreateRoom').addEventListener('click', createRoom);
document.getElementById('btnJoinRoom').addEventListener('click', async () => {
    const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
    if (code) {
        await joinRoom(code);
    } else {
        alert('Please enter a room code');
    }
});
document.getElementById('btnLeaveRoom').addEventListener('click', leaveRoom);
document.getElementById('btnStartMatch').addEventListener('click', startMultiplayerMatch);

// Back Buttons - ALL OF THEM
document.getElementById('btnBackFromStats').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromSelect').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromShop').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromSettings').addEventListener('click', () => {
    document.getElementById('btnBackFromSettings').style.display = 'none';
    showScreen('menu');
});
document.getElementById('btnBackFromPerks').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromMore').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnSettingsMore').addEventListener('click', () => showScreen('settings'));
document.getElementById('btnPerksMore').addEventListener('click', () => { 
    updatePerksUI(); 
    showScreen('perks'); 
});
document.getElementById('btnChristmasMore').addEventListener('click', () => showScreen('christmas'));
document.getElementById('btnBackFromChristmas').addEventListener('click', () => {
    // Remove snowflakes when leaving
    const snowflakes = document.querySelectorAll('.snowflake');
    snowflakes.forEach(s => s.remove());
    showScreen('menu');
});

document.getElementById('btnCoopMore').addEventListener('click', () => {
    showScreen('multiplayer');
});
document.getElementById('btnBackFromPac').addEventListener('click', () => {
    // Hide PAC screen FIRST
    document.getElementById('pacRankScreen').classList.add('hidden');
    
    // Then show menu elements
    showScreen('menu');
    document.getElementById('gameTitle').classList.remove('hidden');
    document.getElementById('coinDisplayMenu').classList.remove('hidden');
    document.getElementById('pacDisplayMenu').classList.remove('hidden');
});
document.getElementById('restartButton').addEventListener('click', () => showScreen('menu'));

// Code Redemption
document.getElementById('btnRedeem').addEventListener('click', () => {
    const code = document.getElementById('codeInput').value;
    redeemCode(code);
});

document.getElementById('codeInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        redeemCode(e.target.value);
    }
});

// Shop Buttons
ui.btnHealth.addEventListener('click', () => buyUpgrade('health'));
ui.btnMagnet.addEventListener('click', () => buyUpgrade('magnet'));
ui.btnTurret.addEventListener('click', () => buyUpgrade('turret'));
ui.btnBomb.addEventListener('click', () => buyUpgrade('bomb'));
ui.btnSkin.addEventListener('click', () => buyUpgrade('skin'));
document.getElementById('unequipSkin').addEventListener('click', () => {
    saveData.upgrades.goldSkinEquipped = false;
    saveDataToStorage();
});

document.getElementById('buyObsidianSkin').addEventListener('click', () => buyUpgrade('obsidianSkin'));
document.getElementById('unequipObsidianSkin').addEventListener('click', () => {
    saveData.upgrades.obsidianSkinEquipped = false;
    saveDataToStorage();
});
document.getElementById('buyCrown').addEventListener('click', () => buyUpgrade('crown'));
document.getElementById('toggleCrown').addEventListener('click', () => toggleCosmetic('crown'));

// Perk Buttons
document.getElementById('btnKnightPerk').addEventListener('click', () => buyPerk('knightBladestorm'));
document.getElementById('btnArcherPerk').addEventListener('click', () => buyPerk('archerRicochet'));

// Hero Select Cards
document.querySelectorAll('.char-select-card').forEach(b => b.addEventListener('click', (e) => {
    e.stopPropagation();
    const heroType = b.dataset.type;
    
    // Check if Zap is locked
    if (heroType === 'zap' && saveData.pac.rank !== 'legend') {
        const msgEl = document.getElementById('codeMessage');
        msgEl.textContent = 'üîí Requires Legend Rank!';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    // Check if Unit-7 is locked
    if (heroType === 'unit7') {
        const rank = saveData.pac.rank;
        if (rank !== 'elite' && rank !== 'legend') {
            const msgEl = document.getElementById('codeMessage');
            msgEl.textContent = 'üîí Requires Elite Rank!';
            msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
            msgEl.classList.remove('hidden');
            setTimeout(() => msgEl.classList.add('hidden'), 3000);
            return;
        }
    }
    
    startGame(heroType);
}));
// Keyboard Controls
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' && !isGameOver && player) {
        player.dash(); 
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Mouse Controls
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    mousePos.x = (e.clientX - rect.left) * scaleX; 
    mousePos.y = (e.clientY - rect.top) * scaleY;
});

window.addEventListener('mousedown', (e) => { 
    if (screens.game.classList.contains('hidden')) return;
    if (!isGameOver && player) player.shoot(); 
});

// Initialize
loadData();
updatePACUI();
initMusic();
applyChristmasMode(); // Apply Christmas theme if enabled
updateChristmasUI(); // Update Christmas UI on load

// Wait for Firebase to fully initialize (Chromebook fix)
setTimeout(() => {
    if (!window.database) {
        console.error('‚ùå Firebase failed to initialize');
    } else {
        console.log('‚úÖ Firebase ready');
    }
}, 2000);

// Unlock Zap hero if Legend rank
function checkZapUnlock() {
    const zapCard = document.getElementById('zapCard');
    if (zapCard) {
        if (saveData.pac.rank === 'legend') {
            zapCard.classList.remove('opacity-50', 'cursor-not-allowed');
            zapCard.classList.add('cursor-pointer');
            const lockIcon = zapCard.querySelector('.absolute.top-0.right-0');
            if (lockIcon) lockIcon.textContent = '‚úì';
        }
    }
    
    // Check Unit-7 unlock (Elite rank or higher)
    const unit7Card = document.getElementById('unit7Card');
    if (unit7Card) {
        const rank = saveData.pac.rank;
        if (rank === 'elite' || rank === 'legend') {
            unit7Card.classList.remove('opacity-50', 'cursor-not-allowed');
            unit7Card.classList.add('cursor-pointer');
            const lockIcon = unit7Card.querySelector('.absolute.top-0.right-0');
            if (lockIcon) lockIcon.textContent = '‚úì';
        }
    }
}

// Call on load and PAC updates
checkZapUnlock();

// =====================================================
// MULTIPLAYER SYSTEM
// =====================================================
let currentRoomCode = null;
let myPlayerId = null;
let opponentPlayer = null;
let opponentProjectiles = [];
let isMultiplayer = false;
let multiplayerGameState = null;
let isCoopMode = false;
let countdown = 0;
let matchStarted = false;
let myHeroType = null;
let opponentHeroType = null;
let respawnTimer = 0;
let isRespawning = false;
let roomListener = null;

// Generate random room code
function generateRoomCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
}

async function createRoom() {
    try {
        if (!window.database) {
            alert('Firebase not initialized. Please refresh the page.');
            return;
        }
        
        currentRoomCode = generateRoomCode();
        myPlayerId = 'player1';
        
        console.log('üéÆ Creating room:', currentRoomCode);
        
        const roomRef = window.dbRef(window.database, 'rooms/' + currentRoomCode);
        
        await window.dbSet(roomRef, {
    host: myPlayerId,
    mode: 'coop',
    players: {
        player1: {
    id: myPlayerId,
    ready: false,
    name: 'Player 1',
    heroType: null,
    x: 200,
    y: 300,
    hp: 100,
    maxHp: 100,
    alive: true,
    angle: 0,
    projectiles: []
}
    },
    gameState: {
        status: 'lobby',
        countdown: 0,
        wave: 1,
        matchStarted: false,
        gameOver: false
    },
    createdAt: Date.now()
});
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        document.getElementById('roomLobby').classList.add('hidden');
        document.getElementById('roomDisplay').classList.remove('hidden');
        document.getElementById('displayRoomCode').textContent = currentRoomCode;
        
        listenToRoom();
        showHeroSelectForMultiplayer();
        
        console.log('‚úÖ Room created successfully');
    } catch (error) {
        alert('Error creating room: ' + error.message);
        console.error('‚ùå Room creation error:', error);
        currentRoomCode = null;
        myPlayerId = null;
    }
}

async function joinRoom(code) {
    try {
        if (!code || code.length !== 6) {
            alert('Please enter a valid 6-character room code');
            return;
        }
        
        const upperCode = code.toUpperCase().trim();
        
        if (!window.database) {
            alert('Firebase not initialized. Please refresh the page.');
            return;
        }
        
        console.log('Attempting to join room:', upperCode);
        
        const roomRef = window.dbRef(window.database, 'rooms/' + upperCode);
        
        const roomSnapshot = await new Promise((resolve) => {
            window.dbOnValue(roomRef, (snap) => {
                resolve(snap);
            }, { onlyOnce: true });
        });
        
        if (!roomSnapshot.exists()) {
            alert('Room not found. Check the code and try again.');
            return;
        }
        
        const roomData = roomSnapshot.val();
        
        if (roomData.players.player2) {
            alert('Room is full!');
            return;
        }
        
        currentRoomCode = upperCode;
        myPlayerId = 'player2';
        
await window.dbUpdate(window.dbRef(window.database, 'rooms/' + upperCode + '/players/player2'), {
    id: 'player2',
    ready: false,
    name: 'Player 2',
    heroType: null,
    x: 600,
    y: 300,
    hp: 100,
    maxHp: 100,
    alive: true,
    angle: 0,
    projectiles: []
});
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        document.getElementById('roomLobby').classList.add('hidden');
        document.getElementById('roomDisplay').classList.remove('hidden');
        document.getElementById('displayRoomCode').textContent = upperCode;
        
        listenToRoom();
        showHeroSelectForMultiplayer();
        
        console.log('‚úÖ Successfully joined room:', upperCode);
    } catch (error) {
        alert('Error joining room: ' + error.message);
        console.error('Join room error:', error);
        currentRoomCode = null;
        myPlayerId = null;
    }
}
// Show hero selection for multiplayer
function showHeroSelectForMultiplayer() {
    const overlay = document.createElement('div');
    overlay.id = 'multiplayerHeroSelect';
    overlay.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
    `;
    
   overlay.innerHTML = `
    <h2 class="text-3xl text-blue-400 mb-6 font-bold">ü§ù CO-OP: SELECT YOUR HERO</h2>
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 mb-6">
            <button class="mp-hero-card char-select-card p-6" data-hero="knight">
                <div class="char-block bg-blue-600 mx-auto"></div>
                <h3 class="text-md text-blue-300 mb-2">Knight</h3>
                <p class="text-[10px] text-gray-400">Wide Cleave</p>
            </button>
            <button class="mp-hero-card char-select-card p-6" data-hero="mage">
                <div class="char-block bg-red-600 mx-auto"></div>
                <h3 class="text-md text-red-300 mb-2">Mage</h3>
                <p class="text-[10px] text-gray-400">Explosive AOE</p>
            </button>
            <button class="mp-hero-card char-select-card p-6" data-hero="archer">
                <div class="char-block bg-green-600 mx-auto"></div>
                <h3 class="text-md text-green-300 mb-2">Archer</h3>
                <p class="text-[10px] text-gray-400">Machine Gun</p>
            </button>
            <button class="mp-hero-card char-select-card p-6" data-hero="ninja">
                <div class="char-block bg-black mx-auto relative">
                    <div class="absolute top-2 left-0 w-full h-3 bg-red-600"></div>
                </div>
                <h3 class="text-md text-gray-300 mb-2">Ninja</h3>
                <p class="text-[10px] text-gray-400">Shuriken Storm</p>
            </button>
            <button class="mp-hero-card char-select-card p-6" data-hero="tempest">
                <div class="char-block bg-gray-300 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-2xl">üå™Ô∏è</div>
                </div>
                <h3 class="text-md text-gray-300 mb-2">Tempest</h3>
                <p class="text-[10px] text-gray-400">Wind Boomerangs</p>
            </button>
        </div>
        <p id="mpHeroStatus" class="text-sm text-gray-400">Choose your hero...</p>
    `;
    
    document.body.appendChild(overlay);
    
    document.querySelectorAll('.mp-hero-card').forEach(card => {
    card.addEventListener('click', async () => {
        const heroType = card.dataset.hero;
        myHeroType = heroType;
        
        await window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/players/' + myPlayerId), {
            heroType: heroType,
            ready: true
        });
        
        // Remove the overlay immediately after selection
        const overlay = document.getElementById('multiplayerHeroSelect');
        if (overlay) overlay.remove();
        
        // Show waiting message in room display
        document.getElementById('waitingText').textContent = `You picked ${heroType.toUpperCase()}! Waiting for teammate...`;
        document.getElementById('waitingText').classList.remove('hidden');
    });
});
}

// Listen to room updates
function listenToRoom() {
    const roomRef = window.dbRef(window.database, 'rooms/' + currentRoomCode);
    
    if (roomListener) {
        roomListener();
    }
    
    roomListener = window.dbOnValue(roomRef, (snapshot) => {
        if (!snapshot.exists()) {
            console.log('‚ö†Ô∏è Room no longer exists');
            leaveRoom();
            return;
        }
        
        const roomData = snapshot.val();
        multiplayerGameState = roomData.gameState;
        updatePlayersList(roomData.players);
        
        // Check if both players selected heroes
        if (roomData.players.player1 && roomData.players.player2) {
            const p1Ready = roomData.players.player1.ready && roomData.players.player1.heroType;
            const p2Ready = roomData.players.player2.ready && roomData.players.player2.heroType;
            
            if (p1Ready && p2Ready) {
                isCoopMode = true; // Mark as co-op mode
                const overlay = document.getElementById('multiplayerHeroSelect');
                if (overlay) overlay.remove();
                
                document.getElementById('waitingText').classList.add('hidden');
                if (myPlayerId === 'player1' && multiplayerGameState.status === 'lobby') {
                    document.getElementById('btnStartMatch').classList.remove('hidden');
                }
                
                const opponentId = myPlayerId === 'player1' ? 'player2' : 'player1';
                opponentHeroType = roomData.players[opponentId].heroType;
            }
        }
        
        // Handle countdown state
        if (multiplayerGameState && multiplayerGameState.status === 'countdown') {
            countdown = multiplayerGameState.countdown;
            console.log('‚è±Ô∏è Countdown:', countdown);
            
            // Player 2 starts their local game when countdown begins
            if (myPlayerId === 'player2' && !isMultiplayer) {
                console.log('üéÆ Player 2 initializing game');
                isMultiplayer = true;
                screens.multiplayer.classList.add('hidden');
                showScreen('game');
                startMultiplayerGame();
            }
        }
        
        // Handle playing state
        if (multiplayerGameState && multiplayerGameState.status === 'playing') {
            if (!matchStarted) {
                console.log('‚ñ∂Ô∏è Match started!');
                matchStarted = true;
                countdown = 0;
            }
        }
        
        // Update opponent data in real-time
        if (isMultiplayer && player) {
            const opponentId = myPlayerId === 'player1' ? 'player2' : 'player1';
            const opponentData = roomData.players[opponentId];
            
            if (opponentData) {
                if (!opponentPlayer) {
                    const stats = GAME_CONFIG.CLASSES[opponentData.heroType];
                    opponentPlayer = {
                        x: opponentData.x,
                        y: opponentData.y,
                        w: GAME_CONFIG.PLAYER.BASE_SIZE,
                        h: GAME_CONFIG.PLAYER.BASE_SIZE,
                        hp: opponentData.hp,
                        maxHp: opponentData.maxHp,
                        color: stats.color,
                        alive: opponentData.alive,
                        angle: opponentData.angle || 0,
                        type: opponentData.heroType
                    };
                } else {
                    opponentPlayer.x = opponentData.x;
                    opponentPlayer.y = opponentData.y;
                    opponentPlayer.hp = opponentData.hp;
                    opponentPlayer.alive = opponentData.alive;
                    opponentPlayer.angle = opponentData.angle || 0;
                }
                
                if (opponentData.projectiles && Array.isArray(opponentData.projectiles)) {
                    opponentProjectiles = opponentData.projectiles.map(p => ({
                        x: p.x,
                        y: p.y,
                        angle: p.angle,
                        type: p.type,
                        w: GAME_CONFIG.PROJECTILES[p.type]?.size || 8,
                        h: GAME_CONFIG.PROJECTILES[p.type]?.size || 8,
                        color: p.color || '#fbbf24'
                    }));
                } else {
                    opponentProjectiles = [];
                }
            }
        }
    });
}
// Update players list display
function updatePlayersList(players) {
    const listEl = document.getElementById('playersList');
    listEl.innerHTML = '';
    
    if (players.player1) {
        listEl.innerHTML += `
            <div class="bg-gray-700 p-3 rounded flex items-center justify-between">
                <span class="text-white text-sm">üë§ Player 1 (Host)</span>
                <span class="text-green-400 text-xs">‚úì Connected</span>
            </div>
        `;
    }
    
    if (players.player2) {
        listEl.innerHTML += `
            <div class="bg-gray-700 p-3 rounded flex items-center justify-between">
                <span class="text-white text-sm">üë§ Player 2</span>
                <span class="text-green-400 text-xs">‚úì Connected</span>
            </div>
        `;
    }
}

// Leave room
async function leaveRoom() {
    if (!currentRoomCode) return;
    
    try {
        if (myPlayerId === 'player1') {
            await window.dbRemove(window.dbRef(window.database, 'rooms/' + currentRoomCode));
        } else {
            await window.dbRemove(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/players/player2'));
        }
        
        if (roomListener) {
            roomListener();
            roomListener = null;
        }
        
        const overlay = document.getElementById('multiplayerHeroSelect');
        if (overlay) overlay.remove();
        
        currentRoomCode = null;
        myPlayerId = null;
        isMultiplayer = false;
        matchStarted = false;
        myHeroType = null;
        opponentHeroType = null;
        opponentPlayer = null;
        
        document.getElementById('roomLobby').classList.remove('hidden');
        document.getElementById('roomDisplay').classList.add('hidden');
        document.getElementById('roomCodeInput').value = '';
        document.getElementById('btnStartMatch').classList.add('hidden');
        
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
        
        console.log('Left room');
    } catch (error) {
        console.error('Error leaving room:', error);
    }
}
async function startMultiplayerMatch() {
    try {
        await window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/gameState'), {
            status: 'countdown',
            countdown: 3
        });
        
        isMultiplayer = true;
        isCoopMode = true;
        matchStarted = false;
        
        screens.multiplayer.classList.add('hidden');
        
        showScreen('game');
        startMultiplayerGame();
        
        // Only host starts countdown
        if (myPlayerId === 'player1') {
            startCountdown();
        }
        
    } catch (error) {
        console.error('Error starting match:', error);
        alert('Failed to start match');
    }
}

function startCountdown() {
    countdown = GAME_CONFIG.MULTIPLAYER.COUNTDOWN_TIME;
    
    if (myPlayerId === 'player1') {
        const countdownInterval = setInterval(async () => {
            countdown--;
            await window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/gameState'), {
                countdown: countdown
            });
            
            if (countdown <= 0) {
                clearInterval(countdownInterval);
                await window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/gameState'), {
                    status: 'playing',
                    matchStarted: true
                });
            }
        }, 1000);
    }
}

function startMultiplayerGame() {
    console.log('üéÆ Starting co-op game for', myPlayerId);
    
    // Pick random map (SAME for both if host sends it)
    if (!currentMap) {
        const mapNames = Object.keys(GAME_CONFIG.MAPS);
        currentMap = mapNames[Math.floor(Math.random() * mapNames.length)];
    }
    generateMapObjects(currentMap);
    
    // Co-op spawn positions (side by side)
    const spawnPos = myPlayerId === 'player1' ? { x: 200, y: 300 } : { x: 600, y: 300 };
    player = new Player(spawnPos.x, spawnPos.y, myHeroType);
    
    // Co-op: Give full HP + upgrades from shop
    const bonusHealth = saveData.upgrades.health * GAME_CONFIG.PLAYER.HP_PER_UPGRADE;
    player.maxHp = GAME_CONFIG.PLAYER.BASE_HP + (GAME_CONFIG.CLASSES[myHeroType].hp_bonus || 0) + bonusHealth;
    player.hp = player.maxHp;
    
    // Co-op: Enemies spawn locally for BOTH players
    enemies = [];
    projectiles = [];
    opponentProjectiles = [];
    effects = [];
    drops = [];
    turrets = [];
    floatingTexts = [];
    keys = {};
    
    sessionCoins = 0;
    sessionTurrets = saveData.inventory.turrets || 0;
    sessionBombs = saveData.inventory.bombs || 0;
    kills = 0;
    wave = 1;
    waveTimer = GAME_CONFIG.WAVES.DURATION * 60;
    enemySpawnTimer = 0;
    difficultyMultiplier = 1;
    bossActive = false;
    currentBoss = null;
    
    // Show turret/bomb HUD
    if(sessionTurrets > 0) ui.turretHud.classList.remove('hidden');
    else ui.turretHud.classList.add('hidden');
    if(sessionBombs > 0) ui.bombHud.classList.remove('hidden');
    else ui.bombHud.classList.add('hidden');
    ui.hudTurretCount.textContent = sessionTurrets;
    ui.hudBombCount.textContent = sessionBombs;
    ui.gameCoins.textContent = 0;
    
    opponentPlayer = null;
    respawnTimer = 0;
    isRespawning = false;
    
    isGameOver = false;
    frameCount = 0;
    
    player.updateUI();
    
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    multiplayerGameLoop();
    
    // Send position + projectiles updates every 50ms
    let updateInterval = setInterval(() => {
        if (!isMultiplayer || !player || !currentRoomCode) {
            clearInterval(updateInterval);
            return;
        }
        
        const myProjectiles = projectiles
            .filter(p => !p.isBossProjectile) // Don't sync boss projectiles
            .map(p => ({
                x: p.x,
                y: p.y,
                angle: p.angle,
                type: p.type,
                color: p.color
            }));
        
        window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/players/' + myPlayerId), {
            x: player.x,
            y: player.y,
            hp: player.hp,
            angle: player.angle,
            alive: player.hp > 0,
            projectiles: myProjectiles
        }).catch(err => console.error('Update error:', err));
    }, 50);
    
    window.multiplayerUpdateInterval = updateInterval;
}
// Draw opponent in game
function drawOpponent() {
    if (!isMultiplayer || !opponentPlayer || !opponentPlayer.alive) return;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(opponentPlayer.x + 4, opponentPlayer.y + 8, opponentPlayer.w, opponentPlayer.h - 4);
    
    // Body
    ctx.fillStyle = opponentPlayer.color;
    ctx.fillRect(opponentPlayer.x, opponentPlayer.y, opponentPlayer.w, opponentPlayer.h);
    
    // Eyes
    ctx.fillStyle = 'white';
    ctx.fillRect(opponentPlayer.x + 4, opponentPlayer.y + 6, 8, 8);
    ctx.fillRect(opponentPlayer.x + 16, opponentPlayer.y + 6, 8, 8);
    ctx.fillStyle = 'black';
    const xOffset = Math.cos(opponentPlayer.angle) * 2;
    const yOffset = Math.sin(opponentPlayer.angle) * 2;
    ctx.fillRect(opponentPlayer.x + 6 + xOffset, opponentPlayer.y + 8 + yOffset, 4, 4);
    ctx.fillRect(opponentPlayer.x + 18 + xOffset, opponentPlayer.y + 8 + yOffset, 4, 4);
    
    // Weapon indicator
    ctx.save();
    ctx.translate(opponentPlayer.x + opponentPlayer.w/2, opponentPlayer.y + opponentPlayer.h/2);
    ctx.rotate(opponentPlayer.angle);
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(12, -3, 16, 6);
    ctx.restore();
    
    // Label - Teammate
ctx.fillStyle = '#22c55e';
ctx.font = '8px "Press Start 2P"';
ctx.textAlign = 'center';
ctx.fillText('TEAMMATE', opponentPlayer.x + opponentPlayer.w/2, opponentPlayer.y - 20);
    
    // HP Bar - BELOW LABEL
    const barWidth = opponentPlayer.w;
    ctx.fillStyle = '#000';
    ctx.fillRect(opponentPlayer.x - 2, opponentPlayer.y - 12, barWidth + 4, 6);
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(opponentPlayer.x, opponentPlayer.y - 10, barWidth * (opponentPlayer.hp / opponentPlayer.maxHp), 2);
    
    ctx.textAlign = 'left';
}

// Multiplayer game loop
function multiplayerGameLoop() {
    gameLoopId = requestAnimationFrame(multiplayerGameLoop);
    
    if (isGameOver) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
        
        effects.forEach(e => e.draw());
        projectiles.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        if (player) player.draw();
        if (opponentPlayer && opponentPlayer.alive) drawOpponent();
        opponentProjectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.w, p.h);
        });
        floatingTexts.forEach(ft => ft.draw());
        return;
    }
    
    // Draw background
    if (currentMap) {
        const mapData = GAME_CONFIG.MAPS[currentMap];
        ctx.fillStyle = mapData.bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = mapData.gridColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
        mapObjects.forEach(obj => obj.draw());
    } else {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (frameCount % 2 === 0) {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
            for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
            ctx.stroke();
        }
    }
    
    // Show countdown
    if (countdown > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#22c55e';
        ctx.font = '72px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(countdown.toString(), canvas.width/2, canvas.height/2);
        ctx.textAlign = 'left';
    }
    
    // Show wave/kills at top center
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(canvas.width/2 - 100, 10, 200, 60);
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 2;
    ctx.strokeRect(canvas.width/2 - 100, 10, 200, 60);
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = '#22c55e';
    ctx.textAlign = 'center';
    ctx.fillText('WAVE ' + wave, canvas.width/2, 32);
    ctx.fillStyle = '#fff';
    ctx.font = '20px "Press Start 2P"';
    ctx.fillText(kills + ' KILLS', canvas.width/2, 58);
    ctx.textAlign = 'left';
    
    // Update teammate HP bar
    if (opponentPlayer) {
        document.getElementById('teammateHpBar').classList.remove('hidden');
        const hpPercent = (opponentPlayer.hp / opponentPlayer.maxHp) * 100;
        document.getElementById('teammateHpFill').style.width = hpPercent + '%';
        document.getElementById('teammateHpText').textContent = Math.floor(opponentPlayer.hp) + '/' + opponentPlayer.maxHp;
        
        if (!opponentPlayer.alive) {
            document.getElementById('teammateHpText').textContent = 'DEAD';
            document.getElementById('teammateHpFill').style.width = '0%';
        }
    }
    
    frameCount++;
    
    // Wave timer
    waveTimer--;
    if (waveTimer <= 0) {
        wave++;
        waveTimer = GAME_CONFIG.WAVES.DURATION * 60;
        const rawMultiplier = 1 + (wave * 0.12);
        difficultyMultiplier = Math.min(rawMultiplier, 3.0);
        
        floatingTexts.push(new FloatingText(canvas.width/2 - 50, 150, 'WAVE ' + wave, '#fbbf24', 24));
        
        // Only host syncs wave to Firebase
        if (myPlayerId === 'player1') {
            window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/gameState'), {
                wave: wave
            });
        }
    }
    
 // Enemy spawning - BOTH players spawn enemies locally
enemySpawnTimer--;
if (enemySpawnTimer <= 0 && matchStarted) {
    const rand = Math.random();
    let type = 'normal';
    
    // Map bonuses
    const mapBonus = 0.30;
    let mapRoll = Math.random();
    if (currentMap === 'desert' && mapRoll < mapBonus && wave >= 1) type = 'ranger';
    else if (currentMap === 'volcano' && mapRoll < mapBonus && wave >= 3) type = 'brute';
    else if (currentMap === 'ice' && mapRoll < mapBonus && wave >= 5) type = 'frosty';
    else if (currentMap === 'forest' && mapRoll < mapBonus && wave >= 6) type = Math.random() < 0.5 ? 'elite_splitter' : 'elite_tank';
    else if (currentMap === 'swamp' && mapRoll < mapBonus && wave >= 7) type = 'elite_specter';
    else {
        if (rand < 0.20) type = 'ranger';
        else if (wave >= 7 && rand >= 0.20 && rand < 0.28) type = 'elite_specter';
        else if (wave >= 6 && rand >= 0.28 && rand < 0.40) type = 'elite_tank';
        else if (wave >= 8 && rand >= 0.40 && rand < 0.52) type = 'elite_splitter';
        else if (wave >= 3 && rand >= 0.52 && rand < 0.67) type = 'brute';
        else if (wave >= 5 && rand >= 0.67 && rand < 0.85) type = 'frosty';
        else type = 'normal';
    }
    
    let ex, ey;
    if (Math.random() < 0.5) {
        ex = Math.random() < 0.5 ? -40 : canvas.width + 40;
        ey = Math.random() * canvas.height;
    } else {
        ex = Math.random() * canvas.width;
        ey = Math.random() < 0.5 ? -40 : canvas.height + 40;
    }
    
    enemies.push(new Enemy(ex, ey, type, difficultyMultiplier));
    
    let spawnRate = Math.max(20, 200 * Math.pow(0.92, wave - 1));
    enemySpawnTimer = spawnRate;
}
    
    // Updates
    effects.forEach((e, i) => {
        e.update(); e.draw();
        if (e.life <= 0) effects.splice(i, 1);
    });
    
    drops.forEach((d, i) => {
        const collected = d.update();
        d.draw();
        if (collected) drops.splice(i, 1);
    });
    
    if (player && player.hp > 0) {
    player.update();
}
    
    // Draw "YOU" label
    if (player && player.hp > 0) {
        ctx.fillStyle = '#22c55e';
        ctx.font = '8px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('YOU', player.x + player.w/2, player.y - 6);
        ctx.textAlign = 'left';
    }
    
    if (opponentPlayer && opponentPlayer.alive) {
        drawOpponent();
    }
    
    // Draw opponent projectiles
    for (let i = opponentProjectiles.length - 1; i >= 0; i--) {
        const p = opponentProjectiles[i];
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle || 0);
        ctx.fillStyle = p.color || '#fbbf24';
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
        
        // Teammate projectiles hit enemies (NOT player)
        let hitEnemy = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (rectCollision(p, enemies[j])) {
                let damage = GAME_CONFIG.PROJECTILES[p.type]?.damage || 5;
                enemies[j].hp -= damage;
                floatingTexts.push(new FloatingText(enemies[j].x, enemies[j].y, `-${Math.round(damage)}`, '#fff', 12));
                if (enemies[j].hp <= 0) {
                    const idx = enemies.indexOf(enemies[j]);
                    if (idx > -1) {
                        enemies.splice(idx, 1);
                        kills++;
                    }
                }
                hitEnemy = true;
                break;
            }
        }
        if (hitEnemy) opponentProjectiles.splice(i, 1);
    }
    
    // Update my projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
       

    
        
        if (p.x < -50 || p.x > canvas.width+50 || p.y < -50 || p.y > canvas.height+50) {
            projectiles.splice(i, 1);
            continue;
        }

let projectileHit = false;
for (let j = enemies.length - 1; j >= 0; j--) {
    // Sync enemy death to Firebase
if (enemies[j].firebaseId) {
    window.dbRemove(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/enemies/' + enemies[j].firebaseId));
}
    if (rectCollision(p, enemies[j])) {
        const dead = enemies[j].takeDamage(p.damage);
        if (dead) {
            // Drop XP and coins (same as normal mode)
            drops.push(new DropItem(enemies[j].x + enemies[j].w/2, enemies[j].y + enemies[j].h/2, 'xp', enemies[j].xpValue));
            
            let coinChance = 0.2 + (wave * 0.02);
            if (Math.random() < coinChance) {
                let coinValue = Math.ceil(wave / 2);
                drops.push(new DropItem(enemies[j].x + enemies[j].w/2, enemies[j].y + enemies[j].h/2, 'coin', coinValue));
            }
            
            enemies.splice(j, 1);
            kills++;
        }
        projectileHit = true;
        break;
    }
}
        if (projectileHit) projectiles.splice(i, 1);
    }
    
    // Enemy collision with players
    enemies.forEach(e => {
        e.update();
        
        // Check collision with me
        if (player && player.hp > 0 && rectCollision(player, e)) {
            if (!player.isDashing && frameCount % 20 === 0) {
                player.hp -= 1;
                floatingTexts.push(new FloatingText(player.x, player.y, `-1 HP`, "red"));
                player.updateUI();
                
               if (player.hp <= 0) {
    player.hp = 0;
    player.updateUI();
    window.dbUpdate(window.dbRef(window.database, 'rooms/' + currentRoomCode + '/players/' + myPlayerId), {
        hp: 0,
        alive: false
    });
    
    // Show death message
    floatingTexts.push(new FloatingText(canvas.width/2 - 50, canvas.height/2, 'YOU DIED!', '#ff0000', 32));
    
    // Check if both dead
    const checkBothDead = setInterval(() => {
        if (opponentPlayer && !opponentPlayer.alive) {
            clearInterval(checkBothDead);
            setTimeout(() => endCoopGame(), 2000);
        }
    }, 500);
    
    // If still waiting after 10 seconds, end game anyway
    setTimeout(() => {
        clearInterval(checkBothDead);
        if (player.hp <= 0) {
            endCoopGame();
        }
    }, 10000);
}
            }
        }
        
        // Check collision with teammate (they handle their own damage)
    });
    
    floatingTexts.forEach((ft, i) => {
        ft.update(); ft.draw();
        if (ft.life <= 0) floatingTexts.splice(i, 1);
    });
}

function endCoopGame() {
    isGameOver = true;
    matchStarted = false;
    isMultiplayer = false;
opponentPlayer = null;
    
    // CAP: Maximum coins per co-op game
    const cappedSessionCoins = Math.min(sessionCoins, 1000);
    
    // Save progress (same as normal mode)
    saveData.coins = parseInt(saveData.coins) + parseInt(cappedSessionCoins);
    saveData.stats.kills = parseInt(saveData.stats.kills) + parseInt(kills);
    
    if (!saveData.stats.heroKills) {
        saveData.stats.heroKills = { knight: 0, mage: 0, archer: 0, ninja: 0, tempest: 0, zap: 0, unit7: 0 };
    }
    saveData.stats.heroKills[player.type] = (saveData.stats.heroKills[player.type] || 0) + parseInt(kills);
    saveData.stats.deaths = parseInt(saveData.stats.deaths) + 1;
    
    // Calculate PAC coins (same as normal)
    const timeAlive = frameCount / 60;
    const rawPAC = calculatePACCoins(wave, kills, timeAlive);
    const earnedPAC = Math.min(rawPAC, 800);
    if (earnedPAC > 0) {
        updatePACRank(earnedPAC);
    }
    
    saveData.inventory.turrets = parseInt(sessionTurrets);
    saveData.inventory.bombs = parseInt(sessionBombs);
    
    if (wave > saveData.stats.bestWave) saveData.stats.bestWave = parseInt(wave);
    if (player.level > saveData.stats.bestLevel) saveData.stats.bestLevel = parseInt(player.level);
    
    saveDataToStorage();
    
    // Show game over screen
    showScreen('gameOver');
    ui.finalKills.textContent = kills;
    ui.finalCoins.textContent = cappedSessionCoins;
    ui.finalWave.textContent = wave;
    document.getElementById('finalPAC').textContent = earnedPAC;
    
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
    }
    
    if (window.multiplayerUpdateInterval) {
        clearInterval(window.multiplayerUpdateInterval);
        window.multiplayerUpdateInterval = null;
    }
    
    leaveRoom();
}

// ‚úÖ ADD THIS NEW SECTION HERE:
// Shop Tab Switching
document.getElementById('tabUpgrades').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.remove('hidden');
    document.getElementById('skinsTab').classList.add('hidden');
    document.getElementById('outfitsTab').classList.add('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-yellow-500 border-yellow-700 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
});

document.getElementById('tabOutfits').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.add('hidden');
    document.getElementById('skinsTab').classList.add('hidden');
    document.getElementById('outfitsTab').classList.remove('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-cyan-500 border-cyan-700 text-white';
    updateChristmasUI(); // Refresh outfit status
});

document.getElementById('tabSkins').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.add('hidden');
    document.getElementById('skinsTab').classList.remove('hidden');
    document.getElementById('outfitsTab').classList.add('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-purple-500 border-purple-700 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
});

document.getElementById('musicToggle').addEventListener('click', toggleMusic);
document.getElementById('christmasToggle').addEventListener('click', toggleChristmas);
// Christmas Present Buttons
document.getElementById('buyBasicPresent').addEventListener('click', () => openPresent('basic'));
document.getElementById('buyPremiumPresent').addEventListener('click', () => openPresent('premium'));
document.getElementById('buyLegendaryPresent').addEventListener('click', () => openPresent('legendary'));

// Christmas Cosmetic Toggles
document.getElementById('toggleSantaHat').addEventListener('click', () => toggleCosmetic('santaHat'));
document.getElementById('toggleElfHat').addEventListener('click', () => toggleCosmetic('elfHat'));
document.getElementById('toggleAntlers').addEventListener('click', () => toggleCosmetic('antlers'));
document.getElementById('toggleCarrot').addEventListener('click', () => toggleCosmetic('carrotNose'));

        });

        // Clean up old rooms every 5 minutes
setInterval(async () => {
    try {
        const roomsRef = window.dbRef(window.database, 'rooms');
        const snapshot = await new Promise((resolve) => {
            window.dbOnValue(roomsRef, resolve, { onlyOnce: true });
        });
        
        if (snapshot.exists()) {
            const rooms = snapshot.val();
            const now = Date.now();
            const oneHourAgo = now - (60 * 60 * 1000);
            
            for (const [code, room] of Object.entries(rooms)) {
                if (room.createdAt < oneHourAgo) {
                    await window.dbRemove(window.dbRef(window.database, 'rooms/' + code));
                    console.log('Deleted old room:', code);
                }
            }
        }
    } catch (error) {
        console.error('Room cleanup error:', error);
    }
}, 5 * 60 * 1000); // Every 5 minutes
    </script>
</body>
</html>